#!/usr/bin/env perl

# =============================================================
#  ____  ____ ____    _   _       _                          _
# | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| |
# |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | |
# | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | |
# |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_|
#
# =============================================================
# Copyright © 2023 Richard Kelsch
# All Rights Reserved
# Licensed under the GNU Public License Version 3
#   See the LICENSE file for details

use strict;
use English qw( -no_match_vars );
use utf8;
use Config;
use open qw(:std :utf8);

# Use threads first, so others inherit
use threads (
    'yield',
    'exit' => 'threads_only',
    'stringify',
);
use threads::shared;

use DBI;
use DBD::mysql;
use Cwd;
use DateTime;
use Time::HiRes qw(time sleep);
use IO::Socket::INET;
use Debug::Easy;
use Getopt::Long;
use Term::ReadKey;
use Term::ANSIScreen qw( :cursor :screen );
use Term::ANSIColor;
use Text::SimpleTable;
use List::Util qw(min max);
use Text::Format;
use Memory::Usage;

use BBS::Universal;

BEGIN {
    our $VERSION = '0.001';
}

# Shared with threads
our $RUNNING : shared         = TRUE;
our $TEST : shared            = FALSE;
our @SERVER_STATUS : shared   = ();
our $UPDATE : shared          = TRUE;
our $ONLINE : shared          = 0;
our $THREADS_RUNNING : shared = 0;
our $START_ROW : shared       = 7;
our $ROW_ADJUST : shared      = 0;

my $OLDDIR         = getcwd;
my $LEVEL          = 'ERROR';
my $SERVER_THREADS = {};

GetOptions(
    'test|sysop'    => \$TEST,
    'debug=s' => \$LEVEL,
);

$LEVEL = uc($LEVEL);
my $DEBUG = Debug::Easy->new(
    'LogLevel' => $LEVEL,
    'Color'    => TRUE,
);

############## BBS Core ###################
print cls;
my $MEMORY = Memory::Usage->new();
$MEMORY->record('Begin Script');
my $BBS_OBJ = BBS::Universal->small_new({ 'debug' => $DEBUG, 'debuglevel' => $LEVEL, 'memory' => $MEMORY });

# Trap all dangerous signals for a thread friendly finish
$SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = sub { hard_finish($BBS_OBJ); };

my $MAX_THREADS = min(int($BBS_OBJ->{'CPU'}->{'CPU CORES'} * $BBS_OBJ->{'CONF'}->{'THREAD MULTIPLIER'}), 99);
chdir($BBS_OBJ->{'CONF'}->{'BBS ROOT'});

my $SYSOP_COMMANDS = {
	'SYSOP SHOW ENVIRONMENT' => sub {
		my $self = shift;
		print $self->sysop_showenv();
		print "\nPress a key to return to the main menu";
		$self->sysop_keypress();
		return('BACK');
	},
	'SYSOP BBS LISTINGS MANAGER' => sub {
		my $self = shift;
		return('BACK');
	},
	'SYSOP FILE MANAGER' => sub {
		my $self = shift;
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/filemanager.ANS'));
	},
	'SYSOP LIST USERS VERTICAL ABBREVIATED' => sub {
		my $self = shift;
		$self->sysop_list_users('VERTICAL ABBREVIATED');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP LIST USERS HORIZONTAL ABBREVIATED' => sub {
		my $self = shift;
		$self->sysop_list_users('HORIZONTAL ABBREVIATED','files/sysop/edituser.ANS');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP LIST USERS VERTICAL DETAILED' => sub {
		my $self = shift;
		$self->sysop_list_users('VERTICAL DETAILED');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP LIST USERS HORIZONTAL DETAILED' => sub {
		my $self = shift;
		$self->sysop_list_users('HORIZONTAL DETAILED');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP EDIT USER' => sub {
		my $self = shift;
		$self->sysop_user_edit($START_ROW + $ROW_ADJUST,'files/sysop/edituser.ANS');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP ADD USER' => sub {
		my $self = shift;
		$self->sysop_user_add($START_ROW + $ROW_ADJUST,'files/sysop/adduser.ANS');
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
	'SYSOP DELETE USER' => sub {
		my $self = shift;
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
	},
    'SYSOP SHUTDOWN' => sub {
        print "\n\nShutting down threads\n";
        {
            lock($RUNNING);
            $RUNNING = FALSE;
        }
    },
    'SYSOP LOGIN SYSOP' => sub {
        run_bbs_sysop(shift, TRUE);
        return('BACK');
    },
    'SYSOP LOGIN' => sub {
        run_bbs_sysop(shift, FALSE);
        return('BACK');
    },
    'SYSOP STATISTICS' => sub {
        my $self = shift;
        return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/statistics.ANS'));
    },
    'BACK' => sub { # Dummy placeholder
    },
    'SYSOP USER MANAGER' => sub {
        my $self = shift;
		return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/usermanager.ANS'));
    },
	'SYSOP SETTINGS' => sub {
		my $self = shift;
		return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/settings.ANS'));
	},
	'SYSOP FIRST TIME SETUP' => sub {
		my $self = shift;
		print "\nThis is for first time setup, if you do this on an already configured system,\nit will wipe everything clean.  Are you sure you want to do this [Y/N]?  ";
		if ($self->sysop_decision()) {
			$self->sysop_first_time_setup(($START_ROW + $ROW_ADJUST));
		}
		return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/settings.ANS'));
	},
	'SYSOP VIEW CONFIGURATION' => sub {
		my $self = shift;
		$self->sysop_view_configuration(TRUE);
		return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/settings.ANS'));
	},
	'SYSOP EDIT CONFIGURATION' => sub {
		my $self = shift;
		$self->sysop_edit_configuration();
		return($self->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/settings.ANS'));
	},
};

binmode(STDOUT, ":encoding(UTF-8)"); # Make sure the screen knows it is UTF-8
system_menu($BBS_OBJ);
$MEMORY->record('Shutting Down');
$MEMORY->dump() if ($LEVEL eq 'DEBUGMAX');
chdir($OLDDIR);
exit(0);

###########################################

sub shutdown_message {
	logo();
	print q{
 ┏━┓╻ ╻╻ ╻╺┳╸╺┳┓┏━┓╻ ╻┏┓╻   ┏━╸┏━┓┏┳┓┏━┓╻  ┏━╸╺┳╸┏━╸
 ┗━┓┣━┫┃ ┃ ┃  ┃┃┃ ┃┃╻┃┃┗┫   ┃  ┃ ┃┃┃┃┣━┛┃  ┣╸  ┃ ┣╸ 
 ┗━┛╹ ╹┗━┛ ╹ ╺┻┛┗━┛┗┻┛╹ ╹   ┗━╸┗━┛╹ ╹╹  ┗━╸┗━╸ ╹ ┗━╸},"\n\n";
}

sub logo {
    my $bbs_obj = shift;
    my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();

    $ROW_ADJUST = 0;

    print setscroll(1, $hsize), locate(1, 1);
    print colored(['red'],         '  ____  ____ ____    _   _       _                          _ ') .  sprintf(' │ Version %.03f', $BBS::Universal::VERSION), "\n";;
    print colored(['yellow'],      ' | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| |'),' │ Written By Richard Kelsch', clline, "\n";
    print colored(['green'],      q{ |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | |}),' │ Copyright © 2023 Richard Kelsch', clline, "\n";
    print colored(['magenta'],     ' | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | |'),' │ All Rights Reserved', clline, "\n";
    print colored(['bright_blue'], ' |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_|'),' │ Licensed under the GNU Public License Version 3', clline, "\n";
    print locate(6, 1), '━' x $wsize;
	print locate(6, 64),'┷';
	print locate($START_ROW, 1),cldown;
    return ($wsize, $hsize, $wpixels, $hpixels);
	# U2537
} ## end sub logo

sub system_menu {
    my $bbs_obj = shift;

    $DEBUG->DEBUG(['Main beginning']);
    my $key = '';

    my ($wsize, $hsize, $wpixels, $hpixels) = logo($bbs_obj);

    my ($width, $height) = ($wsize, $hsize);
    print locate($START_ROW, 1), cldown;

    my $socket;
    unless ($TEST) {
		print 'Loading ' . $MAX_THREADS . ' Threads ...';
        $socket = IO::Socket::INET->new(
            'LocalHost' => $bbs_obj->{'CONF'}->{'HOST'},
            'LocalPort' => $bbs_obj->{'CONF'}->{'PORT'},
            'Proto'     => 'tcp',
            'Listen'    => 5,
            'ReuseAddr' => FALSE,
            'Timeout'   => 5,
            'Blocking'  => TRUE,
        );
        my $error = undef;
        $error = "Cannot create socket for $!n" unless ($socket);
        if (defined($error)) {
            $DEBUG->ERROR([$error, 'Local Mode Only']);
            sleep 5;
        } else {
            $DEBUG->DEBUG(["Waiting for a connection for $bbs_obj->{'CONF'}->{host} : $bbs_obj->{'CONF'}->{port}"]);
            foreach my $thread (1 .. $MAX_THREADS) {
                {
                    lock(@SERVER_STATUS);
                    $SERVER_STATUS[$thread] = FALSE;
                }
                my $name = sprintf('SERVER %02d', $thread);
                $DEBUG->DEBUG(["$name Ready"]);
                $SERVER_THREADS->{$name} = threads->create(
                    \&run_bbs,
                    $bbs_obj,
                    {
                        'thread_number' => $thread,
                        'thread_name'   => $name,
                        'socket'        => $socket,
                        'debuglevel'    => $LEVEL
                    }
                );
                {
                    lock($UPDATE);
                    $UPDATE = TRUE;
                }
                servers_status($bbs_obj, FALSE);
            } ## end foreach my $thread (1 .. $MAX_THREADS)
            $DEBUG->DEBUGMAX([keys %{$SERVER_THREADS}]);
            $SIG{'ALRM'} = sub { servers_status($bbs_obj, TRUE); };
            {
                lock($UPDATE);
                $UPDATE = TRUE;
            }
            servers_status($bbs_obj, TRUE);    # This is a sub not a method, so we pass the object conventionally
        } ## end else [ if (defined($error)) ]
    } ## end unless ($TEST)
    print setscroll(($START_ROW + $ROW_ADJUST), $hsize);
    print locate(($START_ROW + $ROW_ADJUST),1), cldown;

	$MEMORY->record('Initialized and running');
    while ($RUNNING) {
        ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
        if ($wsize != $width || $hsize != $height) {
            alarm(0);
            ($wsize, $hsize, $wpixels, $hpixels) = logo();
            ($width, $height) = ($wsize, $hsize);
            servers_status($bbs_obj, TRUE);
        } ## end if ($wsize != $width ||...)
        my $command = $bbs_obj->sysop_parse_menu(($START_ROW + $ROW_ADJUST), 'files/sysop/sysop.ANS');
		while($command !~ /BACK/ && $RUNNING) {
			$DEBUG->DEBUG(["Running command $command"]);
			$command = $SYSOP_COMMANDS->{$command}->($bbs_obj);
			threads->yield();
		}
    } ## end while ($RUNNING)
    $socket->close() if (defined($socket));
    finish($bbs_obj);
    $DEBUG->DEBUG(['Main End']);
	shutdown_message();
} ## end sub system_menu

sub servers_status {
    my $bbs_obj    = shift;
    my $show_alarm = shift || TRUE;
    if ($UPDATE) {
        alarm(0);
        my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
        my $stp   = int($wsize / 26);
        my $steps = $stp;
        my @row   = ();
        my @sizes;
        foreach my $count (1 .. $stp) {
            push(@sizes, 22);
        }

        my $table = Text::SimpleTable->new(@sizes);
        my $count = 1;
        $ROW_ADJUST = 2;
		{
			lock($ONLINE);
			$ONLINE = 0;
			lock($THREADS_RUNNING);
			$THREADS_RUNNING = 0;
		}
        foreach my $name (sort(keys %{$SERVER_THREADS})) {
            my $status = '';
            if ($SERVER_STATUS[$count] == TRUE) {
                $status = 'CONNECTED';
				lock($ONLINE);
				$ONLINE++;
				lock($THREADS_RUNNING);
				$THREADS_RUNNING++;
            } elsif ($SERVER_STATUS[$count] == FALSE) {
                $status = 'IDLE';
				lock($THREADS_RUNNING);
				$THREADS_RUNNING++;
            } else {
                $status = 'FINISHED';
				lock($THREADS_RUNNING);
				$THREADS_RUNNING--;
            }
            push(@row, "$name -> $status");
            $steps--;
            if ($steps == 0) {
                $steps = $stp;
                $table->row(@row);
                @row = ();
                $ROW_ADJUST++;
            } ## end if ($steps == 0)
            $count++;
            threads->yield();
        } ## end foreach my $name (sort(keys...))
        if (scalar(@row)) {
            while ($steps >= 0) {
                push(@row, ' ');
                $steps--;
                threads->yield();
            }
            $ROW_ADJUST++;
            $table->row(@row);
            lock($UPDATE);
            $UPDATE = FALSE;
        } ## end if (scalar(@row))
        my $tbl = $bbs_obj->center($table->boxes->draw(), $wsize);
        my $cn  = colored(['green'],   'CONNECTED');
        my $idl = colored(['magenta'], 'IDLE');
        my $fn  = colored(['red'],     'FINISHED');
        $tbl =~ s/CONNECTED/$cn/g;
        $tbl =~ s/IDLE/$idl/g;
        $tbl =~ s/FINISHED/$fn/g;

        if ($show_alarm) {
            print savepos, chr(27), locate($START_ROW, 1), $tbl, loadpos;
            $SIG{ALRM} = sub { servers_status($bbs_obj, TRUE); };
            alarm(1);
        } else {
            print locate($START_ROW, 1), $tbl;
        }
    } ## end if ($UPDATE)
    return (TRUE);
} ## end sub servers_status

sub run_bbs {
    my $bbs_obj = shift;

    # Only allow the main program to respond to signals, not the threads
    local $SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = $SIG{'ALRM'} = undef;
    my $params        = shift;
    my $thread_name   = $params->{'thread_name'};
    my $thread_number = $params->{'thread_number'};
    my $socket        = $params->{'socket'};
    my $debug         = Debug::Easy->new(
        'LogLevel'        => $params->{'debuglevel'},
        'Color'           => TRUE,
        'Prefix'          => '%Date% %Time% %Benchmark% %Loglevel% ' . $thread_name . ' [%Subroutine%][%Lastline%] ',
        'DEBUGMAX-Prefix' => '%Date% %Time% %Benchmark% %Loglevel% ' . $thread_name . ' [%Module%][%Lines%] ',
    );
    $debug->DEBUG(["BBS Server Thread $thread_name Started"]);
    $debug->DEBUGMAX([$params]);

    while ($RUNNING) {
        {
            my $client_socket = $socket->accept();
            if (defined($client_socket)) {
                {
                    lock(@SERVER_STATUS);
                    $SERVER_STATUS[$thread_number] = TRUE;
                    lock($UPDATE);
                    $UPDATE = TRUE;
                }
                $debug->DEBUG(['Client connected from ' . $client_socket->peerhost() . ':' . $client_socket->peerport()]);
                my $bbs = BBS::Universal->new(
                    {
                        'thread_name'   => $thread_name . 'socket' => $socket,
                        'client_socket' => $client_socket,
                        'debug'         => $debug,
                        'debuglevel'    => $params->{'debuglevel'},
                    }
                );
                $bbs->run(FALSE);
                shutdown($client_socket, 1);    # Hang up
                {
                    lock(@SERVER_STATUS);
                    $SERVER_STATUS[$thread_number] = FALSE;
                    lock($UPDATE);
                    $UPDATE = TRUE;
                }
            } ## end if (defined($client_socket...))
        }
        threads->yield();
    } ## end while ($RUNNING)
    {
        lock(@SERVER_STATUS);
        $SERVER_STATUS[$thread_number] = -1;
    }
    $debug->INFO(["Thread $thread_name shutting down"]);
} ## end sub run_bbs

sub run_bbs_sysop {
    my $bbs_obj = shift;
    my $sysop = shift;

    # Only allow the main program to respond to signals, not the threads
#    local $SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = undef;
	print locate(($START_ROW + $ROW_ADJUST),1),cldown;
	my $bbs = BBS::Universal->new(
		{
			'thread_name' => 'CONSOLE',
			'debug'       => $DEBUG,
	        'local_mode'  => TRUE,
		}
	);
	$bbs->run($sysop);
	threads->yield() if (!$TEST);    # Be friendly
} ## end sub run_bbs_sysop

sub clean_joinable {
    my $bbs_obj = shift;
    alarm(0);
	while(threads->list(threads::running)) {
		foreach my $thread (threads->list(threads::joinable)) {
			$thread->join();
			{
				lock($UPDATE);
				$UPDATE = TRUE;
			}
			servers_status($bbs_obj,FALSE);
			alarm 0;
			threads->yield();
		}
		threads->yield();
	}
	foreach my $thread (threads->list(threads::joinable)) {
		$thread->join();
		{
			lock($UPDATE);
			$UPDATE = TRUE;
		}
		servers_status($bbs_obj,FALSE);
		alarm 0;
		threads->yield();
	}
} ## end sub clean_joinable

sub finish {
    my $bbs_obj = shift;
    {
        lock($RUNNING);
        $RUNNING = FALSE;
    }
    $DEBUG->INFO(['Shutting Down, waiting for all sessions to end nicely...']);
    clean_joinable($bbs_obj);
    my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
    print setscroll(1, $hsize), color('reset'), cls;
    $DEBUG->INFO(['Shutdown Complete']);
    chdir($OLDDIR);
    alarm(0);
} ## end sub finish

sub hard_finish {
    my $bbs_obj = shift;

    # Force a hard finish.
    #
    # It unceremoniously kills all threads (and disconnects anyone connected to them)

    {    # Always use semaphores when writing to a shared variable
        lock($RUNNING);
        $RUNNING = FALSE;
    }
    $DEBUG->WARNING(['Forcing Shutdown...']);
    sleep 2;
    foreach my $thread (threads::running) {
        $thread->kill('KILL');
    }
    clean_joinable();
    my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
    print setscroll(1, $hsize), color('reset'), cls;
    $DEBUG->INFO(['Hard Shutdown Complete']);
    chdir($OLDDIR);
    alarm(0);
} ## end sub hard_finish

__END__

=pod
=encoding utf8

=head1 NAME

 BBS::Universal

 =============================================================
  ____  ____ ____    _   _       _                          _ 
 | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| |
 |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | |
 | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | |
 |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_|

 =============================================================

=head1 DESCRIPTION

A Universal BBS that connects to TCP/IP instead of serial

It works with a variety of text encoding formats

NOTE:  The System Operator terminal MUST support UTF-8!  This gives graphics character support.

=over 4

=item B<ASCII>

Simple plain ASCII text

=item B<ATASCII>

Atari 8 bit ATASCII

It has graphics characters and cursor movement

=item B<PETSCII>

Commodore 8 bit PETSCII

It has color, graphics characters and cursor movement

=item B<ANSI>

ANSI encoded text

It has color, graphics characters and cursor movement.  Typically used on Terminals and Unix/Linux/Windows/Mac consoles and terminal clients.

=back

=cut
