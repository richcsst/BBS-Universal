#!/usr/bin/env perl

# =============================================================
#  ____  ____ ____    _   _       _                          _
# | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| |
# |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | |
# | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | |
# |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_|
#
# =============================================================
# BBS::Universal
# Copyright © 2023-2025 Richard Kelsch
# All Rights Reserved
# Licensed under the GNU Public License Version 3
#   See the LICENSE file for details

use 5.010;
use strict;
use English qw( -no_match_vars );
use utf8;
use charnames ':full';
use Config;
use open qw(:std :utf8);
no warnings;

# Use threads first, so others inherit
use threads (
    'yield',
    'exit' => 'threads_only',
    'stringify',
);

use DBI;
use DBD::mysql;
use Cwd;
use DateTime;
use Time::HiRes qw(time sleep);
use Debug::Easy;
use Getopt::Long;
use Term::ReadKey;
use Term::ANSIScreen qw( :cursor :screen );
use Term::ANSIColor;
use Text::SimpleTable;
use List::Util qw(min max);
use Text::Format;
use IO::Socket qw(AF_INET SOCK_STREAM SHUT_WR SHUT_RDWR SHUT_RD);
use Cache::Memcached::Fast;

use BBS::Universal;

BEGIN {
    our $VERSION = '0.003';
}

binmode(STDOUT, ':encoding(UTF-8)');

my $OLDDIR         = getcwd;
my $LEVEL          = 'ERROR';
my $SERVER_THREADS = {};
my $RESTART        = FALSE;
my @CALL           = @ARGV;
my $SINGLE         = FALSE;
my $MPLAYER        = FALSE;
my $NOSOUND        = FALSE;

# Shared with threads

our $TEST = FALSE;

GetOptions(
    'test|sysop' => \$TEST,
    'debug=s'    => \$LEVEL,
    'single'     => \$SINGLE,
	'nosound'    => \$NOSOUND,
);

$LEVEL = uc($LEVEL);
my $DEBUG = Debug::Easy->new(
    'LogLevel' => $LEVEL,
    'Color'    => TRUE,
);

############## BBS Core ###################
print cls,locate(1,1),'Initializing...';
my $BBS_OBJ = BBS::Universal->small_new({ 'debug' => $DEBUG, 'debuglevel' => $LEVEL, 'nosound' => $NOSOUND });
my $CACHE   = Cache::Memcached::Fast->new(
    {
        'servers' => [
            {
                'address' => $BBS_OBJ->{'CONF'}->{'MEMCACHED HOST'} . ':' . $BBS_OBJ->{'CONF'}->{'MEMCACHED PORT'},
            },
        ],
        'namespace'      => $BBS_OBJ->{'CONF'}->{'MEMCACHED NAMESPACE'},
        'utf8'           => TRUE,
		'close_on_error' => TRUE,
    }
);
$CACHE->flush_all;
$CACHE->enable_compress(TRUE);
$CACHE->set_multi(
	['RUNNING',         TRUE],
	['TEST',            $TEST],
	['UPDATE',          TRUE],
	['ONLINE',          0],
	['THREADS_RUNNING', 0],
	['ROW_ADJUST',      0],
	['START_ROW',       7],
	['SHOW_STATUS',     TRUE],
	['NOSOUND',         $NOSOUND],
);
# Trap all dangerous signals for a thread friendly finish
$SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = sub { hard_finish($BBS_OBJ); };

my $MAX_THREADS = ($SINGLE) ? 1 : min(int($BBS_OBJ->{'CPU'}->{'CPU CORES'} * $BBS_OBJ->{'CONF'}->{'THREAD MULTIPLIER'}), 99);
chdir($BBS_OBJ->{'CONF'}->{'BBS ROOT'});

our $SYSOP_COMMANDS = {
    'SYSOP SHOW ENVIRONMENT' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/environment.ANS'));
    },
    'SYSOP BBS LISTINGS MANAGER' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/bbs_listing_manager.ANS'));
    },
    'SYSOP BBS EDIT' => sub {
        my $self = shift;
        $self->sysop_edit_bbs();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/bbs_listing_manager.ANS'));
    },
    'SYSOP BBS ADD' => sub {
        my $self = shift;
        $self->sysop_add_bbs();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/bbs_listing_manager.ANS'));
    },
    'SYSOP BBS DELETE' => sub {
        my $self = shift;
        $self->sysop_delete_bbs();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/bbs_listing_manager.ANS'));
    },
    'SYSOP BBS LIST VIEW' => sub {
        my $self = shift;
        $self->sysop_list_bbs();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/bbs_listing_manager.ANS'));
    },
    'SYSOP EDIT FILE CATEGORIES' => sub {
        my $self = shift;
        $self->sysop_edit_file_categories();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/filemanager.ANS'));
    },
    'SYSOP SELECT FILE CATEGORY' => sub {
        my $self = shift;

        $self->sysop_select_file_category();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/filemanager.ANS'));
    },
    'SYSOP FILE MANAGER' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/filemanager.ANS'));
    },
    'SYSOP LIST FILES' => sub {
        my $self = shift;
        $self->sysop_list_files();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/filemanager.ANS'));
    },
	'SYSOP DELETE FILES' => sub {
		my $self = shift;
		$self->sysop_delete_files();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/filemanager.ANS'));
	},
    'SYSOP LIST USERS VERTICAL ABBREVIATED' => sub {
        my $self = shift;
        $self->sysop_list_users('VERTICAL ABBREVIATED');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP LIST USERS HORIZONTAL ABBREVIATED' => sub {
        my $self = shift;
        $self->sysop_list_users('HORIZONTAL ABBREVIATED', 'files/sysop/edituser.ANS');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP LIST USERS VERTICAL DETAILED' => sub {
        my $self = shift;
        $self->sysop_list_users('VERTICAL DETAILED');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP LIST USERS HORIZONTAL DETAILED' => sub {
        my $self = shift;
        $self->sysop_list_users('HORIZONTAL DETAILED');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP EDIT USER' => sub {
        my $self = shift;
        $self->sysop_user_edit($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST'), 'files/sysop/edituser.ANS');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP ADD USER' => sub {
        my $self = shift;
        $self->sysop_user_add($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST'), 'files/sysop/adduser.ANS');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP DELETE USER' => sub {
        my $self = shift;
        $self->sysop_user_delete($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST'), 'files/sysop/deleteuser.ANS');
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP SHUTDOWN' => sub {
		my $self = shift;
		$self->output("\nShutdown BBS (y/N)?  ");
		if ($self->sysop_decision) {
			print "\n", colored(['bright_yellow','on_red'],' Shutting down threads '), "\n";
			$CACHE->set('RUNNING', FALSE);
		} else {
			return('BACK');
		}
    },
    'SYSOP RESTART' => sub {
        print "\n\nShutting down threads\n";
        $CACHE->set('RUNNING', FALSE);
        $RESTART = TRUE;
    },
    'SYSOP LOGIN SYSOP' => sub {
        run_bbs_sysop(shift, TRUE);
        return ('BACK');
    },
    'SYSOP LOGIN' => sub {
        run_bbs_sysop(shift, FALSE);
        return ('BACK');
    },
    'SYSOP STATISTICS' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/statistics.ANS'));
    },
    'BACK' => sub {    # Dummy placeholder
    },
    'SYSOP USER MANAGER' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/usermanager.ANS'));
    },
    'SYSOP SETTINGS' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/settings.ANS'));
    },
    'SYSOP FIRST TIME SETUP' => sub {
        my $self = shift;
        print "\nThis is for first time setup, if you do this on an already configured system,\nit will wipe everything clean.  Are you sure you want to do this [Y/N]?  ";
        if ($self->sysop_decision()) {
            $self->sysop_first_time_setup(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')));
        }
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/settings.ANS'));
    },
    'SYSOP VIEW CONFIGURATION' => sub {
        my $self = shift;
        $self->sysop_view_configuration(TRUE);
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/settings.ANS'));
    },
    'SYSOP EDIT CONFIGURATION' => sub {
        my $self = shift;
        $self->sysop_edit_configuration();
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/settings.ANS'));
    },
    'SYSOP LIST COMMANDS' => sub {
        my $self = shift;
        return ($self->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/commands_reference.ANS'));
    },
};
$BBS_OBJ->playit('startup.mp3');
system_menu($BBS_OBJ);
chdir($OLDDIR);
if ($RESTART) {
    print "\n\nRESTARTING...\n";
    exec($ENV{'_'}, @CALL);
}

exit(0);

###########################################

sub shutdown_message {
    logo();
    print q{
 ┏━┓╻ ╻╻ ╻╺┳╸╺┳┓┏━┓╻ ╻┏┓╻   ┏━╸┏━┓┏┳┓┏━┓╻  ┏━╸╺┳╸┏━╸
 ┗━┓┣━┫┃ ┃ ┃  ┃┃┃ ┃┃╻┃┃┗┫   ┃  ┃ ┃┃┃┃┣━┛┃  ┣╸  ┃ ┣╸ 
 ┗━┛╹ ╹┗━┛ ╹ ╺┻┛┗━┛┗┻┛╹ ╹   ┗━╸┗━┛╹ ╹╹  ┗━╸┗━╸ ╹ ┗━╸}, "\n\n";
} ## end sub shutdown_message

sub logo {
    my $bbs_obj = shift;
    my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();

    $CACHE->set('ROW_ADJUST', 0);

    print setscroll(1, $hsize), locate(1, 1);
    print colored(['red','on_black'], clline .         '  ____  ____ ____    _   _       _                          _  ') . colored(['on_black'],sprintf('│ Version %.03f', $BBS::Universal::VERSION)), "\n";
    print colored(['yellow','on_black'], clline .      ' | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| | '), colored(['on_black'], '│ Written By Richard Kelsch'), "\n";
    print colored(['green','on_black'], clline .      q{ |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | | }), colored(['on_black'], '│ Copyright © 2023-2025 Richard Kelsch'), "\n";
    print colored(['magenta','on_black'], clline .     ' | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | | '), colored(['on_black'], '│ All Rights Reserved'), "\n";
    print colored(['bright_blue','on_black'], clline . ' |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_| '), colored(['on_black'], '│ Licensed under the GNU Public License Version 3'), "\n";
    print locate(6, 1), colored(['on_black'], '━' x $wsize);
    print locate(6, 64), colored(['on_black'],'┷');
    print locate($CACHE->get('START_ROW'), 1),  cldown;
    return ($wsize, $hsize, $wpixels, $hpixels);
} ## end sub logo

sub system_menu {
    my $bbs_obj = shift;

    $DEBUG->DEBUG(['Main beginning']);
    my $key = '';

    my ($wsize, $hsize, $wpixels, $hpixels) = logo($bbs_obj);

    my ($width, $height) = ($wsize, $hsize);
    print locate($CACHE->get('START_ROW'), 1), cldown;

    my $socket;
    unless ($TEST) {
        print 'Loading ' . $MAX_THREADS . ' Threads ...';
        $socket = IO::Socket->new(
            'Domain'    => AF_INET,
            'LocalHost' => $bbs_obj->{'CONF'}->{'HOST'},
            'LocalPort' => $bbs_obj->{'CONF'}->{'PORT'},
            'Type'      => SOCK_STREAM,
            'Proto'     => 'tcp',
            'Listen'    => 1,
            'ReuseAddr' => TRUE,
            'ReusePort' => TRUE,
            'Timeout'   => 1,
            'Blocking'  => FALSE,
        );
        my $error = undef;
        $error = "Cannot create socket for $!n" unless ($socket);
        if (defined($error)) {
            $DEBUG->ERROR([$error, 'Local Mode Only']);
            sleep 5;
        } else {
            $DEBUG->DEBUG(["Waiting for a connection for $bbs_obj->{'CONF'}->{host} : $bbs_obj->{'CONF'}->{port}"]);
            foreach my $thread (1 .. $MAX_THREADS) {
                my $name = sprintf('SERVER_%02d', $thread);
                $DEBUG->DEBUG(["$name Ready"]);
                $SERVER_THREADS->{$name} = threads->create(
                    \&run_bbs,
                    $bbs_obj,
                    {
                        'thread_number' => $thread,
                        'thread_name'   => $name,
                        'socket'        => $socket,
                        'debuglevel'    => $LEVEL
                    }
                );
                $CACHE->set('UPDATE', TRUE);
                servers_status($bbs_obj, FALSE);
            } ## end foreach my $thread (1 .. $MAX_THREADS)
            $DEBUG->DEBUGMAX([keys %{$SERVER_THREADS}]);
            $SIG{'ALRM'} = sub { servers_status($bbs_obj, TRUE); };
            $CACHE->set('UPDATE', TRUE);
            servers_status($bbs_obj, TRUE);    # This is a sub not a method, so we pass the object conventionally
        }
    }
    print setscroll(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), $hsize);
    print locate(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 1), cldown;
    $bbs_obj->{'sysop'} = TRUE;
    $bbs_obj->users_load('sysop', '');
    while ($CACHE->get('RUNNING')) {
        ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
        if ($wsize != $width || $hsize != $height) {
            alarm(0);
            ($wsize, $hsize, $wpixels, $hpixels) = logo();
            ($width, $height) = ($wsize, $hsize);
            servers_status($bbs_obj, TRUE) unless ($TEST);
        } ## end if ($wsize != $width ||...)
        my $command = $bbs_obj->sysop_parse_menu(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 'files/sysop/sysop.ANS');
        while ($command !~ /BACK/ && $CACHE->get('RUNNING')) {
            $DEBUG->DEBUG(["Running command $command"]);
            if (exists($SYSOP_COMMANDS->{$command}) && ref($SYSOP_COMMANDS->{$command}) eq 'CODE') {
                $command = $SYSOP_COMMANDS->{$command}->($bbs_obj);
            } else {
                $DEBUG->ERROR(["$command is not a valid SysOp Command!"]);
                $command = 'BACK';
            }
            threads->yield();
        } ## end while ($command !~ /BACK/...)
    } ## end while ($CACHE->get('RUNNING'...))
    $socket->close() if (defined($socket));
    $CACHE->set('RUNNING', FALSE);
    finish($bbs_obj);
    $DEBUG->DEBUG(['Main End']);
    shutdown_message();
} ## end sub system_menu

sub servers_status {
    my $bbs_obj    = shift;
    my $show_alarm = shift;

	if ($CACHE->get('SHOW_STATUS') && ! $bbs_obj->{'LOCAL LOGIN'}) {
		if ($CACHE->get('UPDATE') && !$TEST) {
			alarm(0);
			my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
			my $stp   = int($wsize / 26);
			my $steps = $stp;
			my @row   = ();
			my @sizes;
			foreach my $count (1 .. $stp) {
				push(@sizes, 22);
			}

			my $table = Text::SimpleTable->new(@sizes);
			my $count = 1;
			$CACHE->set_multi(
				['ROW_ADJUST',      2],
				['ONLINE',          0],
				['THREADS_RUNNING', 0],
			);
			foreach my $name (sort(keys %{$SERVER_THREADS})) {
				if ($CACHE->get($name) eq 'CONNECTED') {
					$CACHE->set_multi(
						['ONLINE',          $CACHE->get('ONLINE') + 1],
						['THREADS_RUNNING', $CACHE->get('THREADS_RUNNING') + 1],
						[$name,             'CONNECTED'],
					);
				} elsif ($CACHE->get($name) eq 'IDLE') {
					$CACHE->set_multi(
						['THREADS_RUNNING', $CACHE->get('THREADS_RUNNING') + 1],
						[$name,             'IDLE'],
					);
				} else {
					$CACHE->set_multi(
						['THREADS_RUNNING', $CACHE->get('THREADS_RUNNING') - 1],
						[$name,             'FINISHED'],
					);
				}
				push(@row, "$name -> " . $CACHE->get($name));
				$steps--;
				if ($steps == 0) {
					$steps = $stp;
					$table->row(@row);
					@row = ();
					$CACHE->set('ROW_ADJUST', $CACHE->get('ROW_ADJUST') + 1);
				} ## end if ($steps == 0)
				$count++;
				threads->yield();
			} ## end foreach my $name (sort(keys...))
			if (scalar(@row)) {
				while ($steps >= 0) {
					push(@row, ' ');
					$steps--;
					threads->yield();
				}
				$CACHE->set('ROW_ADJUST', $CACHE->get('ROW_ADJUST') + 1);
				$table->row(@row);
				$CACHE->set('UPDATE', FALSE);
			} ## end if (scalar(@row))
			if (defined($table)) {
				my $tbl = locate($CACHE->get('START_ROW'),1) . $bbs_obj->center($table->boxes->draw(), $wsize);
				my $cn  = colored(['green'],   'CONNECTED');
				my $idl = colored(['magenta'], 'IDLE');
				my $fn  = colored(['red'],     'FINISHED');
				$tbl =~ s/CONNECTED/$cn/g;
				$tbl =~ s/IDLE/$idl/g;
				$tbl =~ s/FINISHED/$fn/g;

				if ($show_alarm) {
					print savepos, $tbl, loadpos;
					$SIG{ALRM} = sub { servers_status($bbs_obj, TRUE); };
					alarm(1);
				} else {
					print $tbl;
				}
			}
		} ## end if ($CACHE->get('UPDATE'...))
	}
    return (TRUE);
} ## end sub servers_status

sub run_bbs {
    my $bbs_obj = shift;

    # Only allow the main program to respond to signals, not the threads
    local $SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = $SIG{'ALRM'} = undef;
    my $params        = shift;
    my $thread_name   = $params->{'thread_name'};
    my $thread_number = $params->{'thread_number'};
    my $socket        = $params->{'socket'};
    my $debug         = Debug::Easy->new(
        'LogLevel'        => $params->{'debuglevel'},
        'Color'           => TRUE,
        'Prefix'          => '%Date% %Time% %Benchmark% %Loglevel% ' . $thread_name . ' [%Subroutine%][%Lastline%] ',
        'DEBUGMAX-Prefix' => '%Date% %Time% %Benchmark% %Loglevel% ' . $thread_name . ' [%Module%][%Lines%] ',
    );
    $debug->DEBUG(["BBS Server Thread $thread_name Started"]);
    $debug->DEBUGMAX([$params]);

    while ($CACHE->get('RUNNING')) {
        $CACHE->set($thread_name, 'IDLE');
        my $client_socket = $socket->accept();
        if (defined($client_socket)) {
            binmode($client_socket, ':ultra-raw');
            $CACHE->set_multi(
				[$thread_name, 'CONNECTED'],
				['UPDATE',     TRUE],
			);
            $debug->DEBUG(['Client connected from ' . $client_socket->peerhost() . ':' . $client_socket->peerport()]);
            $debug->DEBUG(['Creating new BBS::Universal object']);
            my $bbs = BBS::Universal->new(
                {
                    'thread_name'   => $thread_name,
                    'thread_number' => $thread_number,
                    'socket'        => $socket,
                    'client_socket' => $client_socket,
                    'debug'         => $debug,
                    'debuglevel'    => $params->{'debuglevel'},
                }
            );
            $debug->DEBUG(['BBS::Universal object created', 'Running connection process']);
            $bbs->run(FALSE);
            $debug->DEBUG(['Shutdown client socket']);
            $client_socket->shutdown(SHUT_RDWR);    # Hang up
            $CACHE->set_multi(
				[$thread_name, 'IDLE'],
				['UPDATE',     TRUE],
			);
        } else {
            $CACHE->set_multi(
				[$thread_name, 'IDLE'],
				['UPDATE',     TRUE],
			);
        }
        threads->yield();
    } ## end while ($CACHE->get('RUNNING'...))
    $CACHE->set($thread_name, 'TERMINATED');
    $debug->INFO(["Thread $thread_name shutting down"]);
} ## end sub run_bbs

sub run_bbs_sysop {
    my $bbs_obj = shift;
    my $sysop   = shift;

	$bbs_obj->{'LOCAL LOGIN'} = TRUE;
    # Only allow the main program to respond to signals, not the threads
    #    local $SIG{'QUIT'} = $SIG{'INT'} = $SIG{'KILL'} = $SIG{'TERM'} = $SIG{'HUP'} = undef;
    print locate(($CACHE->get('START_ROW') + $CACHE->get('ROW_ADJUST')), 1), cldown;
    my $bbs = BBS::Universal->new(
        {
            'thread_name' => 'CONSOLE',
            'debug'       => $DEBUG,
            'local_mode'  => TRUE,
        }
    );
    $bbs->run($sysop);
	delete($bbs_obj->{'LOCAL LOGIN'});
    threads->yield() if (!$TEST);    # Be friendly
} ## end sub run_bbs_sysop

sub clean_joinable {
    my $bbs_obj = shift;
    alarm(0);
    while (threads->list(threads::running)) {
        foreach my $thread (threads->list(threads::joinable)) {
            $thread->join();
            $CACHE->set('UPDATE', TRUE);
            servers_status($bbs_obj, FALSE);
            alarm 0;
            threads->yield();
        } ## end foreach my $thread (threads...)
        threads->yield();
    } ## end while (threads->list(threads::running...))
    foreach my $thread (threads->list(threads::joinable)) {
        $thread->join();
        $CACHE->set('UPDATE', TRUE);
        servers_status($bbs_obj, FALSE);
        alarm 0;
        threads->yield();
    } ## end foreach my $thread (threads...)
} ## end sub clean_joinable

sub finish {
    my $bbs_obj = shift;
	$bbs_obj->playit('shutdown.mp3');
    $CACHE->set('RUNNING', FALSE);
    $DEBUG->INFO(['Shutting Down, waiting for all sessions to end nicely...']);
    clean_joinable($bbs_obj);
    $DEBUG->INFO(['Shutdown Complete']);
    chdir($OLDDIR);
    system('reset');
    alarm(0);
} ## end sub finish

sub hard_finish {
    my $bbs_obj = shift;

    # Force a hard finish.
    #
    # It unceremoniously kills all threads (and disconnects anyone connected to them)

    $CACHE->set('RUNNING', FALSE);

    $DEBUG->WARNING(['Forcing Shutdown...']);
    alarm(0);
    sleep 1;
    if ($TEST) {
        print "Skipping threads\n";
    } else {
        foreach my $thread (threads->list(threads::running)) {
            $thread->kill('KILL');
        }
        clean_joinable();
    } ## end else [ if ($TEST) ]
    $DEBUG->INFO(['Hard Shutdown Complete']);
    chdir($OLDDIR);
    system('reset');
    shutdown_message();
    exit(1);
} ## end sub hard_finish

__END__

=pod
=encoding utf8

=head1 NAME

 BBS::Universal

 =============================================================
  ____  ____ ____    _   _       _                          _ 
 | __ )| __ ) ___|  | | | |_ __ (_)_   _____ _ __ ___  __ _| |
 |  _ \|  _ \___ \  | | | | '_ \| \ \ / / _ \ '__/ __|/ _` | |
 | |_) | |_) |__) | | |_| | | | | |\ V /  __/ |  \__ \ (_| | |
 |____/|____/____/   \___/|_| |_|_| \_/ \___|_|  |___/\__,_|_|

 =============================================================

=head1 DESCRIPTION

A Universal BBS that connects to TCP/IP instead of serial

It works with a variety of text encoding formats

NOTE:  The System Operator terminal MUST support UTF-8!  This gives graphics character support.

=over 4

=item B<ASCII>

Simple plain ASCII text

=item B<ATASCII>

Atari 8 bit ATASCII

It has graphics characters and cursor movement

=item B<PETSCII>

Commodore 8 bit PETSCII

It has color, graphics characters and cursor movement

=item B<ANSI>

ANSI encoded text

It has color, graphics characters and cursor movement.  Typically used on Terminals and Unix/Linux/Windows/Mac consoles and terminal clients.

=back

=cut
