package BBS::Universal;

# Pragmas
use 5.010;
use strict;
no strict 'subs';
no warnings;

# use Carp::Always;
use utf8;
use constant {
    TRUE        => 1,
    FALSE       => 0,
    YES         => 1,
    NO          => 0,
    BLOCKING    => 1,
    NONBLOCKING => 0,
    PASSWORD    => -1,
    ECHO        => 1,
    SILENT      => 0,
	NUMERIC     => 2,

    ASCII   => 0,
    ATASCII => 1,
    PETSCII => 2,
    ANSI    => 3,

	LINEMODE          => 34,

    SE                => 240,
    NOP               => 214,
    DATA_MARK         => 242,
    BREAK             => 243,
    INTERRUPT_PROCESS => 244,
    ABORT_OUTPUT      => 245,
    ARE_YOU_THERE     => 246,
    ERASE_CHARACTER   => 247,
    ERASE_LINE        => 248,
    GO_AHEAD          => 249,
    SB                => 250,
    WILL              => 251,
    WONT              => 252,
    DO                => 253,
    DONT              => 254,
    IAC               => 255,
};
use open qw(:std :utf8);

# Modules
use threads (
    'yield',
    'exit' => 'threads_only',
    'stringify',
);
use English qw( -no_match_vars );
use Config;
use Debug::Easy;
use DateTime;
use DBI;
use DBD::mysql;
use File::Basename;
use Time::HiRes qw(time sleep);
use Term::ReadKey;
use Term::ANSIScreen qw( :cursor :screen );
use Term::ANSIColor;
use Text::Format;
use Text::SimpleTable;
use List::Util qw(min max);
use IO::Socket qw(AF_INET SOCK_STREAM SHUT_WR SHUT_RDWR SHUT_RD);
use Cache::Memcached::Fast;

BEGIN {
    require Exporter;

    our $VERSION = '0.005';
    our @ISA     = qw(Exporter);
    our @EXPORT  = qw(
		TRUE
		FALSE
		YES
		NO
		BLOCKING
		NONBLOCKING
		PASSWORD
		ECHO
		SILENT
		NUMERIC

		ASCII
		ATASCII
		PETSCII
		ANSI

		LINEMODE

		SE
		NOP
		DATA_MARK
		BREAK
		INTERRUPT_PROCESS
		ABORT_OUTPUT
		ARE_YOU_THERE
		ERASE_CHARACTER
		ERASE_LINE
		GO_AHEAD
		SB
		WILL
		WONT
		DO
		DONT
		IAC
    );
    our @EXPORT_OK = qw();
    binmode(STDOUT, ":encoding(UTF-8)");
}

sub DESTROY {
    my $self = shift;

    $self->{'dbh'}->disconnect();
}

sub small_new {
    my $class = shift;
    my $self  = shift;

    bless($self, $class);
    $self->populate_common();

    $self->{'CACHE'} = Cache::Memcached::Fast->new(
        {
            'servers' => [
                {
                    'address' => $self->{'CONF'}->{'MEMCACHED HOST'} . ':' . $self->{'CONF'}->{'MEMCACHED PORT'},
                },
            ],
            'namespace' => $self->{'CONF'}->{'MEMCACHED NAMESPACE'},
            'utf8'      => TRUE,
        }
    );
    return ($self);
}

sub new {    # Always call with the socket as a parameter
    my $class = shift;

    my $params    = shift;
    my $socket    = (exists($params->{'socket'}))        ? $params->{'socket'}        : undef;
    my $cl_socket = (exists($params->{'client_socket'})) ? $params->{'client_socket'} : undef;
    my $lmode     = (exists($params->{'local_mode'}))    ? $params->{'local_mode'}    : FALSE;

    my $os   = `/usr/bin/uname -a`;
    my $self = {
        'thread_name'     => $params->{'thread_name'},
        'thread_number'   => $params->{'thread_number'},
        'local_mode'      => $lmode,
        'debuglevel'      => $params->{'debuglevel'},
        'debug'           => $params->{'debug'},
        'socket'          => $socket,
        'cl_socket'       => $cl_socket,
        'peerhost'        => (defined($cl_socket)) ? $cl_socket->peerhost() : undef,
        'peerport'        => (defined($cl_socket)) ? $cl_socket->peerport() : undef,
        'os'              => $os,
        'width'           => 40,
        'height'          => 24,
        'tab_stop'        => 4,
        'backspace'       => chr(8),
        'carriage_return' => chr(13),
        'line_feed'       => chr(10),
        'tab_stop'        => chr(9),
        'bell'            => chr(7),
        'ack'             => chr(6),
        'nak'             => chr(15),
        'vertical_tab'    => chr(11),
        'form_feed'       => chr(12),
        'xoff'            => chr(19),
        'xon'             => chr(17),
        'esc'             => chr(27),
        'can'             => chr(24),
        'null'            => chr(0),
        'delete'          => chr(127),
        'suffixes'        => [qw( ASC ATA PET ANS )],
        'host'            => undef,
        'port'            => undef,
		'access_levels'   => {
			'USER'         => 0,
			'VETERAN'      => 1,
			'JUNIOR SYSOP' => 2,
			'SYSOP'        => 3,
		},
		'telnet_commands' => [
			'SE (Subnegotiation end)',
			'NOP (No operation)',
			'Data Mark',
			'Break',
			'Interrupt Process',
			'Abort output',
			'Are you there?',
			'Erase character',
			'Erase Line',
			'Go ahead',
			'SB (Subnegotiation begin)',
			'WILL',
			"WON'T",
			'DO',
			"DON'T",
			'IAC',
		],
		'telnet_options'  => [
			'Binary Transmission',
			'Echo',
			'Reconnection',
			'Suppress Go Ahead',
			'Approx Message Size Negotiation',
			'Status',
			'Timing Mark',
			'Remote Controlled Trans and Echo',
			'Output Line Width',
			'Output Page Size',
			'Output Carriage-Return Disposition',
			'Output Horizontal Tab Stops',
			'Output Horizontal Tab Disposition',
			'Output Formfeed Disposition',
			'Output Vertical Tabstops',
			'Output Vertical Tab Disposition',
			'Output Linefeed Disposition',
			'Extended ASCII',
			'Logout',
			'Byte Macro',
			'Data Entry Terminal',
			'RFC 1043',
			'RFC 732',
			'SUPDUP',
			'RFC 736',
			'RFC 734',
			'SUPDUP Output',
			'Send Location',
			'Terminal Type',
			'End of Record',
			'TACACS User Identification',
			'Output Marking',
			'Terminal Location Number',
			'Telnet 3270 Regime',
			'30X.3 PAD',
			'Negotiate About Window Size',
			'Terminal Speed',
			'Remote Flow Control',
			'Linemode',
			'X Display Location',
			'Environment Option',
			'Authentication Option',
			'Encryption Option',
			'New Environment Option',
			'TN3270E',
			'XAUTH',
			'CHARSET',
			'Telnet Remote Serial Port (RSP)',
			'Com Port Control Option',
			'Telnet Suppress Local Echo',
			'Telnet Start TLS',
			'KERMIT',
			'SEND-URL',
			'FORWARD_',
		],
    };

    bless($self, $class);
    $self->populate_common();
    $self->{'CACHE'} = Cache::Memcached::Fast->new(
        {
            'servers' => [
                {
                    'address' => $self->{'CONF'}->{'MEMCACHED HOST'} . ':' . $self->{'CONF'}->{'MEMCACHED PORT'},
                },
            ],
            'namespace' => $self->{'CONF'}->{'MEMCACHED NAMESPACE'},
            'utf8'      => TRUE,
        }
    );

    return ($self);
} ## end sub new

sub populate_common {
    my $self = shift;

    $self->{'CPU'}      = $self->cpu_info();
    $self->{'CONF'}     = $self->configuration();
    $self->{'VERSIONS'} = $self->parse_versions();
    $self->{'USER'}     = {
        'text_mode'   => $self->{'CONF'}->{'DEFAULT TEXT MODE'},
        'max_columns' => 80,
        'max_rows'    => 25,
    };
    $self->db_initialize();
    $self->ascii_initialize();
    $self->atascii_initialize();
    $self->petscii_initialize();
    $self->ansi_initialize();
    $self->filetransfer_initialize();
    $self->messages_initialize();
    $self->users_initialize();
    $self->sysop_initialize();
    $self->cpu_initialize();
    $self->news_initialize();
    $self->bbs_list_initialize();
    chomp(my $os = `uname -a`);
    $self->{'SPEEDS'} = {    # This depends on the granularity of Time::HiRes
        'FULL'  => 0,
        '300'   => 0.02,
        '1200'  => 0.005,
        '2400'  => 0.0025,
        '4800'  => 0.00125,
        '9600'  => 0.000625,
        '19200' => 0.0003125,
    };

	$self->{'FORTUNE'} = (-e '/usr/bin/fortune' || -e '/usr/local/bin/fortune') ? TRUE : FALSE;
    $self->{'TOKENS'} = {
        'CPU IDENTITY' => $self->{'CPU'}->{'CPU IDENTITY'},
        'CPU CORES'    => $self->{'CPU'}->{'CPU CORES'},
        'CPU SPEED'    => $self->{'CPU'}->{'CPU SPEED'},
        'CPU THREADS'  => $self->{'CPU'}->{'CPU THREADS'},
        'OS'           => $os,
        'PERL VERSION' => $self->{'VERSIONS'}->[0],
        'BBS VERSION'  => $self->{'VERSIONS'}->[1],
        'SYSOP'        => sub {
            my $self = shift;
            if ($self->{'sysop'}) {
                return ('SYSOP CREDENTIALS');
            } else {
                return ('USER CREDENTIALS');
            }
        },
		'FORTUNE' => sub {
			my $self = shift;
			return($self->get_fortune);
		},
        'BANNER' => sub {
            my $self   = shift;
            my $banner = $self->files_load_file('files/main/banner');
            return ($banner);
        },
        'FILE CATEGORY' => sub {
            my $self = shift;
            return ($self->users_file_category());
        },
        'FORUM CATEGORY' => sub {
            my $self = shift;
            return ($self->users_forum_category());
        },
        'USER INFO' => sub {
            my $self = shift;
            return ($self->users_info());
        },
        'BBS NAME' => sub {
            my $self = shift;
            return ($self->{'CONF'}->{'BBS NAME'});
        },
        'AUTHOR NAME' => sub {
            my $self = shift;
            return ($self->{'CONF'}->{'STATIC'}->{'AUTHOR NAME'});
        },
        'USER PERMISSIONS' => sub {
            my $self = shift;
            return ($self->dump_permissions);
        },
        'USER ID' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'id'});
        },
        'USER FULLNAME' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'fullname'});
        },
        'USER USERNAME' => sub {
            my $self = shift;
            if ($self->{'USER'}->{'prefer_nickname'}) {
                return ($self->{'USER'}->{'nickname'});
            } else {
                return ($self->{'USER'}->{'username'});
            }
        },
        'USER NICKNAME' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'nickname'});
        },
        'USER EMAIL' => sub {
            my $self = shift;
            if ($self->{'USER'}->{'show_email'}) {
                return ($self->{'USER'}->{'email'});
            } else {
                return ('[HIDDEN]');
            }
        },
        'USER COLUMNS' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'max_columns'});
        },
        'USER ROWS' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'max_rows'});
        },
        'USER SCREEN SIZE' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'max_columns'} . 'x' . $self->{'USER'}->{'max_rows'});
        },
        'USER GIVEN' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'given'});
        },
        'USER FAMILY' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'family'});
        },
        'USER LOCATION' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'location'});
        },
        'USER BIRTHDAY' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'birthday'});
        },
        'USER RETRO SYSTEMS' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'retro_systems'});
        },
        'USER LOGIN TIME' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'login_time'});
        },
        'USER TEXT MODE' => sub {
            my $self = shift;
            return ($self->{'USER'}->{'text_mode'});
        },
        'BAUD RATE' => sub {
            my $self = shift;
            return ($self->{'baud_rate'});
        },
        'TIME' => sub {
            my $self = shift;
            return (DateTime->now);
        },
        'UPTIME' => sub {
            my $self = shift;
            chomp(my $uptime = `uptime -p`);
            return ($uptime);
        },
        'SHOW BBS LIST' => sub {
            my $self = shift;
            return ($self->bbs_list_all());
        },
        'SHOW USERS LIST' => sub {
            my $self = shift;
            return ($self->users_list());
        },
        'ONLINE' => sub {
            my $self = shift;
            return ($self->{'CACHE'}->get('ONLINE'));
        },
        'VERSIONS' => 'placeholder',
        'UPTIME'   => 'placeholder',
    };

    $self->{'COMMANDS'} = {
        'UPDATE ACCOMPLISHMENTS' => sub {
            my $self = shift;
			$self->users_update_accomplishments();
            return ($self->load_menu('files/main/account'));
        },
		'FORUM CATEGORIES' => sub {
			my $self = shift;
			$self->messages_forum_categories();
            return ($self->load_menu('files/main/forums'));
		},
		'FORUM MESSAGES LIST' => sub {
			my $self = shift;
			$self->messages_list_messages();
            return ($self->load_menu('files/main/forums'));
		},
		'FORUM MESSAGES READ' => sub {
			my $self = shift;
			$self->messages_read_message();
            return ($self->load_menu('files/main/forums'));
		},
		'FORUM MESSAGES EDIT' => sub {
			my $self = shift;
			$self->messages_edit_message('EDIT');
            return ($self->load_menu('files/main/forums'));
		},
		'FORUM MESSAGES ADD' => sub {
			my $self = shift;
			$self->messages_edit_message('ADD');
            return ($self->load_menu('files/main/forums'));
		},
		'FORUM MESSAGES DELETE' => sub {
			my $self = shift;
			$self->messages_delete_message();
            return ($self->load_menu('files/main/forums'));
		},
        'UPDATE LOCATION' => sub {
            my $self = shift;
			$self->users_update_location();
            return ($self->load_menu('files/main/account'));
        },
        'UPDATE EMAIL' => sub {
            my $self = shift;
			$self->users_update_email();
            return ($self->load_menu('files/main/account'));
        },
        'UPDATE RETRO SYSTEMS' => sub {
            my $self = shift;
			$self->users_update_retro_systems();
            return ($self->load_menu('files/main/account'));
        },
		'CHANGE ACCESS LEVEL' => sub {
			my $self = shift;
			$self->users_change_access_level();
			return($self->load_menu('files/main/account'));
		},
		'CHANGE BAUD RATE' => sub {
			my $self = shift;
			$self->users_change_baud_rate();
			return($self->load_menu('files/main/account'));
		},
		'CHANGE DATE FORMAT' => sub {
			my $self = shift;
			$self->users_change_date_format();
			return($self->load_menu('files/main/account'));
		},
        'CHANGE SCREEN SIZE' => sub {
            my $self = shift;
            $self->users_change_screen_size();
            return ($self->load_menu('files/main/account'));
        },
        'CHOOSE TEXT MODE' => sub {
            my $self = shift;
			$self->users_update_text_mode();
            return ($self->load_menu('files/main/account'));
        },
        'TOGGLE SHOW EMAIL' => sub {
            my $self = shift;
            $self->users_toggle_permission('show_email');
            return ($self->load_menu('files/main/account'));
        },
        'TOGGLE PREFER NICKNAME' => sub {
            my $self = shift;
            $self->users_toggle_permission('prefer_nickname');
            return ($self->load_menu('files/main/account'));
        },
        'TOGGLE PLAY FORTUNES' => sub {
            my $self = shift;
            $self->users_toggle_permission('play_fortunes');
            return ($self->load_menu('files/main/account'));
        },
        'BBS LIST ADD' => sub {
            my $self = shift;
            $self->bbs_list_add();
            return ($self->load_menu('files/main/bbs_listing'));
        },
        'BBS LISTING' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/bbs_listing'));
        },
		'LIST USERS' => sub {
			my $self = shift;
			return($self->load_menu('files/main/list_users'));
		},
        'ACCOUNT MANAGER' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/account'));
        },
        'BACK' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/menu'));
        },
        'DISCONNECT' => sub {
            my $self = shift;
            $self->output("\nDisconnect, are you sure (y|N)?  ");
            unless ($self->decision()) {
                return ($self->load_menu('files/main/menu'));
            }
            $self->output("\n");
        },
        'FILE CATEGORY' => sub {
            my $self = shift;
            $self->choose_file_category();
            return ($self->load_menu('files/main/files_menu'));
        },
        'FILES' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/files_menu'));
        },
        'LIST FILES SUMMARY' => sub {
            my $self = shift;
            $self->files_list_summary(FALSE);
            return ($self->load_menu('files/main/files_menu'));
        },
        'LIST FILES DETAILED' => sub {
            my $self = shift;
            $self->files_list_detailed(FALSE);
            return ($self->load_menu('files/main/files_menu'));
        },
        'SEARCH FILES SUMMARY' => sub {
            my $self = shift;
            $self->files_list_summary(TRUE);
            return ($self->load_menu('files/main/files_menu'));
        },
        'SEARCH FILES DETAILED' => sub {
            my $self = shift;
            $self->files_list_detailed(TRUE);
            return ($self->load_menu('files/main/files_menu'));
        },
        'NEWS' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/news'));
        },
        'NEWS SUMMARY' => sub {
            my $self = shift;
            $self->news_summary();
            return ($self->load_menu('files/main/news'));
        },
        'NEWS DISPLAY' => sub {
            my $self = shift;
            $self->news_display();
            return ($self->load_menu('files/main/news'));
        },
        'FORUMS' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/forums'));
        },
        'ABOUT' => sub {
            my $self = shift;
            return ($self->load_menu('files/main/about'));
        },
    };
}

sub run {
    my $self  = shift;
    my $sysop = shift;

    $self->{'sysop'} = $sysop;
    $self->{'ERROR'} = undef;

	my $handle = $self->{'cl_socket'};
	print $handle chr(IAC) . chr(WONT) . chr(LINEMODE) unless($self->{'localmode'} || $self->{'sysop'});$|=1;
    if ($self->greeting()) {    # Greeting also logs in
        $self->main_menu('files/main/menu');
    }
    $self->disconnect();
    return (defined($self->{'ERROR'}));
} ## end sub run

sub greeting {
    my $self = shift;

    # Load and print greetings message here
	$self->output("\n\n");
    my $text = $self->files_load_file('files/main/greeting');
    $self->output($text);
    return ($self->login());    # Login will also create new users
}

sub login {
    my $self = shift;

    my $valid = FALSE;

    my $username;
    if ($self->{'sysop'}) {
        $username = 'sysop';
        $self->output("\n\nAuto-login of $username successful\n\n");
        $valid = $self->users_load($username, '');
		if ($self->{'local_mode'}) { # override DB values
			my ($wsize, $hsize, $wpixels, $hpixels) = GetTerminalSize();
			$self->{'USER'}->{'columns'} = $wsize;
		}
    } else {
        my $tries = $self->{'CONF'}->{'LOGIN TRIES'} + 0;
        do {
            do {
                $self->output("\n" . 'Please enter your username ("NEW" if you are a new user) > ');
                $username = $self->get_line(ECHO, 32);
                $tries-- if ($username eq '');
                last     if ($tries <= 0 || !$self->is_connected());
            } until ($username ne '');
            if ($self->is_connected()) {
                if (uc($username) eq 'NEW') {
                    $valid = $self->create_account();
                } elsif ($username eq 'sysop' && !$self->{'local_mode'}) {
                    $self->output("\n\nSysOp cannot connect remotely\n\n");
                } else {
                    $self->output("\n\nPlease enter your password > ");
                    my $password = $self->get_line(PASSWORD, 64);
                    $valid = $self->users_load($username, $password);
                }
                if ($valid) {
                    $self->output("\n\nWelcome " . $self->{'fullname'} . ' (' . $self->{'username'} . ")\n\n");
                } else {
                    $self->output("\n\nLogin incorrect\n\n");
                    $tries--;
                }
            }
            last unless ($self->{'CACHE'}->get('RUNNING'));
            last unless ($self->is_connected());
        } until ($valid || $tries <= 0);
    }
    return ($valid);
}

sub create_account {
    my $self = shift;
    return (FALSE);
}

sub is_connected {
    my $self = shift;

	if ($self->{'local_mode'}) {
		return(TRUE);
	} elsif ($self->{'CACHE'}->get('RUNNING') && ($self->{'sysop'} || defined($self->{'cl_socket'}))) {
        $self->{'CACHE'}->set(sprintf('SERVER_%02d', $self->{'thread_number'}), 'CONNECTED');
        $self->{'CACHE'}->set('UPDATE', TRUE);
        return (TRUE);
    } else {
        $self->{'CACHE'}->set(sprintf('SERVER_%02d', $self->{'thread_number'}), 'IDLE');
        $self->{'CACHE'}->set('UPDATE', TRUE);
        return (FALSE);
    }
}

sub decision {
    my $self = shift;

    my $response = uc($self->get_key(SILENT, BLOCKING));
    if ($response eq 'Y') {
        $self->output("YES\n");
        return (TRUE);
    }
    $self->output("NO\n");
    return (FALSE);
}

sub prompt {
    my $self = shift;
    my $text = shift;

    my $response;
    if ($self->{'USER'}->{'text_mode'} eq 'ATASCII') {
        $response = '(' . colored(['bright_yellow'],$self->{'USER'}->{'username'}) . ') ' . $text . chr(31) . ' ';
    } elsif ($self->{'USER'}->{'text_mode'} eq 'PETSCII') {
        $response = '(' . $self->{'USER'}->{'username'} . ') ' . "$text > ";
    } elsif ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        $response = '(' . colored(['bright_yellow'],$self->{'USER'}->{'username'}) . ') ' . $text . ' ' . $self->{'ansi_characters'}->{'BLACK RIGHT-POINTING TRIANGLE'} . ' ';
    } else {
        $response = '(' . $self->{'USER'}->{'username'} . ') ' . "$text > ";
    }
    return ($response);
}

sub menu_choice {
    my $self   = shift;
    my $choice = shift;
    my $color  = shift;
    my $desc   = shift;

    if ($self->{'USER'}->{'text_mode'} eq 'ATASCII') {
        $self->output(" $choice " . chr(31) . " $desc");
    } elsif ($self->{'USER'}->{'text_mode'} eq 'PETSCII') {
        $self->output(" $choice > $desc");
    } elsif ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        $self->output(
			$self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT VERTICAL'} .
			'[% ' . $color . ' %]' . $choice . '[% RESET %]' .
			$self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT VERTICAL'} .
			'[% ' . $color . ' %]' . $self->{'ansi_characters'}->{'BLACK RIGHT-POINTING TRIANGLE'} . '[% RESET %]' .
			" $desc"
		);
    } else {
        $self->output(" $choice > $desc");
    }
}

sub show_choices {
    my $self    = shift;
    my $mapping = shift;

    my $keys = '';
    if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        $self->output($self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT ARC DOWN AND RIGHT'} . $self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT HORIZONTAL'} . $self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT ARC DOWN AND LEFT'} . "\n");
    }
	my $odd = 0;
    foreach my $kmenu (sort(keys %{$mapping})) {
        next if ($kmenu eq 'TEXT');
		if ($self->{'access_level'}->{$mapping->{$kmenu}->{'access_level'}} <= $self->{'access_level'}->{$self->{'USER'}->{'access_level'}} ) {
			$self->menu_choice($kmenu, $mapping->{$kmenu}->{'color'}, $mapping->{$kmenu}->{'text'});
			$self->output("\n");
		}
    }
    if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        $self->output($self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT ARC UP AND RIGHT'} . $self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT HORIZONTAL'} . $self->{'ansi_characters'}->{'BOX DRAWINGS LIGHT ARC UP AND LEFT'});
    }
}

sub header {
    my $self = shift;

    my $width = $self->{'USER'}->{'max_columns'};
    my $name  = ' ' . $self->{'CONF'}->{'BBS NAME'} . ' ';

    my $text = '#' x int(($width - length($name)) / 2);
    $text .= $name;
    $text .= '#' x ($width - length($text));
    if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        my $char = '[% BOX DRAWINGS HEAVY HORIZONTAL %]';
        $text =~ s/\#/$char/g;
    }
    return ($self->detokenize_text('[% CLS %]' . $text));
}

sub load_menu {
    my $self = shift;
    my $file = shift;

    my $orig    = $self->files_load_file($file);
    my @Text    = split(/\n/, $orig);
    my $mapping = { 'TEXT' => '' };
    my $mode    = TRUE;
    my $text    = '';
    foreach my $line (@Text) {
        if ($mode) {
			next if ($line =~ /^\#/);
            if ($line !~ /^---/) {
                my ($k, $cmd, $color, $access, $t) = split(/\|/, $line);
                $k     = uc($k);
                $cmd   = uc($cmd);
                $color = uc($color);
                if (exists($self->{'COMMANDS'}->{$cmd})) {
                    $mapping->{$k} = {
                        'command'      => $cmd,
                        'color'        => $color,
						'access_level' => $access,
                        'text'         => $t,
                    };
                } else {
                    $self->{'debug'}->ERROR(["Command Missing!  $cmd"]);
                }
            } else {
                $mode = FALSE;
            }
        } else {
            $mapping->{'TEXT'} .= $self->detokenize_text($line) . "\n";
        }
    }
    $mapping->{'TEXT'} = $self->header() . "\n" . $mapping->{'TEXT'};
    return ($mapping);
}

sub main_menu {
    my $self = shift;
    my $file = shift;

    my $connected = TRUE;
    my $command   = '';
    my $mapping = $self->load_menu($file);
    while ($connected && $self->is_connected()) {
        $self->output($mapping->{'TEXT'});
        $self->show_choices($mapping);
        $self->output("\n" . $self->prompt('Choose'));
        my $key;
        do {
            $key = uc($self->get_key(SILENT, FALSE));
        } until (exists($mapping->{$key}) || $key eq chr(3) || !$self->is_connected());
        $self->output($mapping->{$key}->{'command'} . "\n");
        if ($key eq chr(3)) {
            $command = 'DISCONNECT';
        } else {
            $command = $mapping->{$key}->{'command'};
        }
        $mapping = $self->{'COMMANDS'}->{$command}->($self);
        if (ref($mapping) ne 'HASH' || !$self->is_connected()) {
            $connected = FALSE;
        }
    }
}

sub disconnect {
    my $self = shift;

    # Load and print disconnect message here
    my $text = $self->files_load_file('files/main/disconnect');
    $self->output($text);
    return (TRUE);
}

sub categories_menu {    # Handle categories menu
    my $self = shift;
    return (TRUE);
}

sub parse_telnet_escape {
	my $self    = shift;
	my $command = shift;
	my $option  = shift;
	my $handle  = $self->{'cl_socket'};

	if ($command == WILL) {
		if ($option == ECHO) { # WON'T ECHO
			print $handle chr(IAC) . chr(WONT) . chr(ECHO);
		} elsif ($option == LINEMODE) {
			print $handle chr(IAC) . chr(WONT) . chr(LINEMODE);
		}
	} elsif ($command == DO) {
		if ($option == ECHO) { # DON'T ECHO
			print $handle chr(IAC) . chr(DONT) . chr(ECHO);
		} elsif ($option == LINEMODE) {
			print $handle chr(IAC) . chr(DONT) . chr(LINEMODE);
		}
	} else {
		$self->{'debug'}->DEBUG(['Recreived IAC Request - ' . $self->{'telnet_commands'}->[$command - 240] . ' : ' . $self->{'telnet_options'}->[$option]]);
	}
	return(TRUE);
}

sub flush_input {
	my $self = shift;

	my $key;
	unless ($self->{'local_mode'} || $self->{'sysop'}) {
		my $handle = $self->{'cl_socket'};
		ReadMode 'noecho', $handle;
		do {
			$key = ReadKey(-1,$handle);
		} until (! defined($key) || $key eq '');
		ReadMode 'restore', $handle;
	} else {
		ReadMode 'ultra-raw';
		do {
			$key = ReadKey(-1);
		} until (! defined($key) || $key eq '');
		ReadMode 'restore';
	}
	return(TRUE);
}

sub get_key {
    my $self     = shift;
    my $echo     = shift;
    my $blocking = shift;

    my $key = undef;
	my $timeout = $self->{'USER'}->{'timeout'} * 60;
    local $/ = "\x{00}";
    if ($self->{'local_mode'}) {
        ReadMode 'ultra-raw';
        $key = ($blocking) ? ReadKey($timeout) : ReadKey(-1);
        ReadMode 'restore';
    } elsif ($self->is_connected()) {
		my $handle = $self->{'cl_socket'};
		ReadMode 'ultra-raw', $self->{'cl_socket'};
		my $escape;
		do {
			$escape = FALSE;
			$key = ($blocking) ? ReadKey($timeout, $handle) : ReadKey(-1, $handle);
			if ($key eq chr(255)) { # IAC sequence
				my $command = ReadKey($timeout, $handle);
				my $option  = ReadKey($timeout, $handle);
				$self->parse_telnet_escape(ord($command),ord($option));
				$escape = TRUE;
			}
		} until (! $escape || $self->is_connected());
		ReadMode 'restore', $self->{'cl_socket'};
    }
	return($key) if ($key eq chr(13));
	$key = $self->{'backspace'} if ($key eq chr(127));
	if ($echo == NUMERIC && defined($key)) {
		if ($key =~ /[0-9]/ || $key eq $self->{'backspace'}) {
			$self->send_char($key);
		} else {
			$key = '';
		}
    } elsif ($echo == ECHO && defined($key)) {
        $self->send_char($key);
    } elsif ($echo == PASSWORD && defined($key)) {
        $self->send_char('*');
    }
    return ($key);
}

sub get_line {
    my $self  = shift;
    my $echo  = shift;
    my $limit = (scalar(@_)) ? min(shift, 65535) : 65535;
    my $line  = (scalar(@_)) ? shift : '';
    my $key;

	$self->flush_input();
	$self->output($line) if ($line ne '');
    while ($self->is_connected() && $key ne chr(13) && $key ne chr(3)) {
		if (length($line) < $limit) {
			$key = $self->get_key($echo, BLOCKING);
			return('') if (defined($key) && $key eq chr(3));
			if (defined($key) && $key ne '' && $self->is_connected()) {
				if ($key eq $self->{'backspace'} || $key eq chr(127)) {
					$self->output(" $key");
					my $len = length($line);
					if ($len > 0) {
						$line = substr($line,0, $len - 1);
					}
				} elsif ($key ne chr(13) && $key ne chr(3) && $key ne chr(10) && ord($key) > 31 && ord($key) < 127) {
					$line .= $key;
				}
			}
		} else {
			$key = $self->get_key(SILENT, BLOCKING);
			if (defined($key) && $key eq chr(3)) {
				return('');
			 }
			if (defined($key) && $key eq $self->{'backspace'} || $key eq chr(127)) {
				$key = $self->{'backspace'};
				$self->output("$key $key");
				chop($line);
			} else {
				$self->output('[% RING BELL %]');
			}
		}
        threads->yield();
    }

	$line = '' if ($key eq chr(3));
    return ($line);
}

sub detokenize_text {    # Detokenize text markup
    my $self = shift;
    my $text = shift;

    if (defined($text) && length($text) > 1) {
        foreach my $key (keys %{ $self->{'TOKENS'} }) {
			if ($key eq 'VERSIONS' && $text =~ /\[\%\s+$key\s+\%\]/i) {
				my $versions = '';
				foreach my $names (@{ $self->{'VERSIONS'} }) {
					$versions .= $names . "\n";
				}
				$text =~ s/\[\%\s+$key\s+\%\]/$versions/g;
			} elsif (ref($self->{'TOKENS'}->{$key}) eq 'CODE' && $text =~ /\[\%\s+$key\s+\%\]/) {
				my $ch = $self->{'TOKENS'}->{$key}->($self);    # Code call
				$text =~ s/\[\%\s+$key\s+\%\]/$ch/g;
			} else {
				$text =~ s/\[\%\s+$key\s+\%\]/$self->{'TOKENS'}->{$key}/g;
			}
        }
    }
    return ($text);
}

sub output {
    my $self = shift;
    my $text = $self->detokenize_text(shift);

	if (defined($text) && $text ne '') {
		if ($text =~ /\[\%\s+WRAP\s+\%\]/) {
			my $format = Text::Format->new(
				'columns'     => $self->{'USER'}->{'max_columns'} - 1,
				'tabstop'     => 4,
				'extraSpace'  => TRUE,
				'firstIndent' => 0,
			);
			my $header;
			($header, $text) = split(/\[\%\s+WRAP\s+\%\]/, $text);
			if ($text =~ /\[\%\s+JUSTIFY\s+\%\]/) {
				$text =~ s/\[\%\s+JUSTIFY\s+\%\]//g;
				$format->justify(TRUE);
			}
			$text = $format->format($text);
			$text = $header . $text;
		}
		my $mode = $self->{'USER'}->{'text_mode'};
		if ($mode eq 'ATASCII') {
			$self->atascii_output($text);
		} elsif ($mode eq 'PETSCII') {
			$self->petscii_output($text);
		} elsif ($mode eq 'ANSI') {
			$self->ansi_output($text);
		} else {    # ASCII (always the default)
			$self->ascii_output($text);
		}
	} else {
		return(FALSE);
	}
	return (TRUE);
}

sub send_char {
    my $self = shift;
    my $char = shift;

    # This sends one character at a time to the socket to simulate a retro BBS
    if ($self->{'sysop'} || $self->{'local_mode'} || !defined($self->{'cl_socket'})) {
        print STDOUT $char;
		$| = 1;
    } else {
		my $handle = $self->{'cl_socket'};
        print $handle $char;
		$| = 1;
    }

    # Send at the chosen baud rate by delaying the output by a fraction of a second
    # Only delay if the baud_rate is not FULL
    sleep $self->{'SPEEDS'}->{ $self->{'USER'}->{'baud_rate'} } if ($self->{'USER'}->{'baud_rate'} ne 'FULL');
    return (TRUE);
} ## end sub send_char

sub scroll {
    my $self = shift;
    my $nl   = shift;

    my $string;
    if ($self->{'local_mode'}) {
        $string = "\nScroll?  ";
    } else {
        $string = "$nl" . 'Scroll?  ';
    }
    $self->output($string);
    if ($self->get_key(ECHO, BLOCKIMG) =~ /N/i) {
        return (FALSE);
    }
	$self->output('[% BACKSPACE %] [% BACKSPACE %]' x 10);
    return (TRUE);
}

sub static_configuration {
    my $self = shift;
    my $file = shift;

    $self->{'CONF'}->{'STATIC'}->{'AUTHOR NAME'}     = 'Richard Kelsch';
    $self->{'CONF'}->{'STATIC'}->{'AUTHOR EMAIL'}    = 'Richard Kelsch <rich@rk-internet.com>';
    $self->{'CONF'}->{'STATIC'}->{'AUTHOR LOCATION'} = 'Central Utah - USA';
    if (-e $file) {
        open(my $CFG, '<', $file) or die "$file missing!";
        chomp(my @lines = <$CFG>);
        close($CFG);
        foreach my $line (@lines) {
            next if ($line eq '' || $line =~ /^\#/);
            my ($name, $val) = split(/\s+=\s+/, $line);
            $self->{'CONF'}->{'STATIC'}->{$name} = $val;
        }
    }
}

sub choose_file_category {
    my $self = shift;

    my $table;
    my $choices = [qw(0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)];
    my $hchoice = {};
    my @categories;
    if ($self->{'USER'}->{'max_columns'} <= 40) {
        $table = Text::SimpleTable->new(6, 20, 15);
    } else {
        $table = Text::SimpleTable->new(6, 30, 43);
    }
    $table->row('CHOICE', 'TITLE', 'DESCRIPTION');
    $table->hr();
    my $sth = $self->{'dbh'}->prepare('SELECT * FROM file_categories');
    $sth->execute();
    if ($sth->rows > 0) {
        while (my $row = $sth->fetchrow_hashref()) {
            $table->row($choices->[$row->{'id'} - 1], $row->{'title'}, $row->{'description'});
            $hchoice->{ $choices->[$row->{'id'} - 1] } = $row->{'id'};
            push(@categories, $row->{'title'});
        }
        $sth->finish();
        if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
            $self->output($table->boxes->draw());
        } else {
            $self->output($table->draw());
        }
        $self->output("\n" . $self->prompt('Choose Category (< = Nevermind)'));
        my $response;
        do {
            $response = uc($self->get_key(SILENT, BLOCKING));
        } until (exists($hchoice->{$response}) || $response eq '<' || !$self->is_connected());
        if ($response ne '<') {
            $self->{'USER'}->{'file_category'} = $hchoice->{$response};
            $self->output($categories[$hchoice->{$response} - 1] . "\n");
            $sth = $self->{'dbh'}->prepare('UPDATE users SET file_category=? WHERE id=?');
            $sth->execute($hchoice->{$response}, $self->{'USER'}->{'id'});
            $sth->finish();
        } else {
            $self->output("Nevermind\n");
        }
    }
}

sub configuration {
    my $self = shift;

    unless (exists($self->{'CONF'}->{'STATIC'})) {
        my @static_file = ('./conf/bbs.rc', '~/.bbs_universal/bbs.rc', '/etc/bbs.rc');
        my $found       = FALSE;
        foreach my $file (@static_file) {
            if (-e $file) {
                $found = TRUE;
                $self->static_configuration($file);
                last;
            } else {
                $self->{'debug'}->WARNING(["$file not found, trying the next file in the list"]);
            }
        }
        unless ($found) {
            $self->{'debug'}->ERROR(['BBS Static Configuration file not found', join("\n", @static_file)]);
            exit(1);
        }
        $self->db_connect();
    }
    #######################################################
    my $count = scalar(@_);
    if ($count == 1) {    # Get single value
        my $name = shift;

        my $sth    = $self->{'dbh'}->prepare('SELECT config_value FROM config WHERE config_name=?');
        my $result = $sth->execute($name);
        $sth->finish();
        return ($result);
    } elsif ($count == 2) {    # Set a single value
        my $name = shift;
        my $fval = shift;
        my $sth = $self->{'dbh'}->prepare('UPDATE config SET config_value=? WHERE config_name=?');
        my $result = $sth->execute($fval, $name);
        $sth->finish();
        $self->{'CONF'}->{$name} = $fval;
        return (TRUE);
    } elsif ($count == 0) {    # Get entire configuration forces a reload into CONF
        $self->db_connect() unless (exists($self->{'dbh'}));
        my $sth     = $self->{'dbh'}->prepare('SELECT config_name,config_value FROM config');
        my $results = {};
        $sth->execute();
        while (my @row = $sth->fetchrow_array()) {
            $results->{ $row[0] } = $row[1];
            $self->{'CONF'}->{ $row[0] } = $row[1];
        }
        $sth->finish();
        return ($self->{'CONF'});
    }
}

sub parse_versions {
    my $self = shift;

###
    my $versions = [
		"Perl                          $OLD_PERL_VERSION",
		"BBS Executable                $main::VERSION",
		"BBS::Universal                $BBS::Universal::VERSION",
		"BBS::Universal::ASCII         $BBS::Universal::ASCII_VERSION",
		"BBS::Universal::ATASCII       $BBS::Universal::ATASCII_VERSION",
		"BBS::Universal::PETSCII       $BBS::Universal::PETSCII_VERSION",
		"BBS::Universal::ANSI          $BBS::Universal::ANSI_VERSION",
		"BBS::Universal::BBS_List      $BBS::Universal::BBS_LIST_VERSION",
		"BBS::Universal::CPU           $BBS::Universal::CPU_VERSION",
		"BBS::Universal::Messages      $BBS::Universal::MESSAGES_VERSION",
		"BBS::Universal::SysOp         $BBS::Universal::SYSOP_VERSION",
		"BBS::Universal::FileTransfer  $BBS::Universal::FILETRANSFER_VERSION",
		"BBS::Universal::Users         $BBS::Universal::USERS_VERSION",
		"BBS::Universal::DB            $BBS::Universal::DB_VERSION",
		"BBS::Universal::Text_Editor   $BBS::Universal::TEXT_EDITOR_VERSION",
		"DBI                           $DBI::VERSION",
		"DBD::mysql                    $DBD::mysql::VERSION",
		"DateTime                      $DateTime::VERSION",
		"Debug::Easy                   $Debug::Easy::VERSION",
		"File::Basename                $File::Basename::VERSION",
		"Time::HiRes                   $Time::HiRes::VERSION",
		"Term::ReadKey                 $Term::ReadKey::VERSION",
		"Term::ANSIScreen              $Term::ANSIScreen::VERSION",
		"Text::Format                  $Text::Format::VERSION",
		"Text::SimpleTable             $Text::SimpleTable::VERSION",
		"IO::Socket                    $IO::Socket::VERSION",
	];
###
    return ($versions);
}

sub yes_no {
    my $self  = shift;
    my $bool  = 0 + shift;
    my $color = shift;

    if ($color && $self->{'USER'}->{'text_mode'} eq 'ANSI') {
        if ($bool) {
            return ('[% GREEN %]YES[% RESET %]');
        } else {
            return ('[% RED %]NO[% RESET %]');
        }
    } else {
        if ($bool) {
            return ('YES');
        } else {
            return ('NO');
        }
    }
}

sub get_uptime {
    my $self = shift;

    chomp(my $uptime = `uptime -p`);
    return (ucfirst($uptime));
}

sub pad_center {
    my $self  = shift;
    my $text  = shift;
    my $width = shift;

    if (defined($text) && $text ne '') {
        my $size    = length($text);
        my $padding = int(($width - $size) / 2);
        if ($padding > 0) {
            $text = ' ' x $padding . $text;
        }
    }
    return ($text);
}

sub center {
    my $self  = shift;
    my $text  = shift;
    my $width = shift;

	unless (defined($text) && $text ne '') {
		return ($text);
	}
    if ($text =~ /\n/s) {
        chomp(my @lines = split(/\n/, $text));
        $text = '';
        foreach my $line (@lines) {
            $text .= $self->pad_center($line, $width) . "\n";
        }
        return ($text);
    } else {
        return ($self->pad_center($text, $width));
    }
}

sub trim {
    my $self = shift;
    my $text = shift;

    $text =~ s/^\s+//;
    $text =~ s/\s+$//;
    return ($text);
}

sub get_fortune {
	my $self = shift;
	return(($self->{'USER'}->{'play_fortunes'}) ? `fortune -s -u` : '');
}

sub playit {
	my $self = shift;
	my $file = shift;

	unless($self->{'nosound'}) {
		if ((-e '/usr/bin/mplayer' || -e '/usr/local/bin/mplayer') && $self->configuration('PLAY SYSOP SOUNDS') =~ /TRUE|1/i) {
			system("mplayer -really-quiet sysop_sounds/$file 1>/dev/null 2>&1 &");
		}
	}
}

sub check_access_level {
	my $self   = shift;
	my $access = shift;

	if ($self->{'access_levels'}->{$access} <= $self->{'access_levels'}->{$self->{'USER'}->{'access_level'}}) {
		return(TRUE);
	}
	return(FALSE);
}

# MANUAL IMPORT HERE #

1;
