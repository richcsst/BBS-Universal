package BBS::Universal;

# Pragmas
use 5.010;
use strict;
no strict 'subs';
no warnings;
use utf8;
use constant {
    TRUE        => 1,
    FALSE       => 0,
	YES         => 1,
	NO          => 0,
    BLOCKING    => 1,
    NONBLOCKING => 0,
	PASSWORD    => -1,
	ECHO        => 1,
	SILENT      => 0,

    ASCII   => 0,
    ATASCII => 1,
    PETSCII => 2,
    ANSI    => 3,
};
use open qw(:std :utf8);

# Modules
use threads (
	'yield',
	'exit' => 'threads_only',
	'stringify',
);
use English qw( -no_match_vars );
use Config;
use Debug::Easy;
use DateTime;
use DBI;
use DBD::mysql;
use File::Basename;
use Time::HiRes qw(time sleep);
use Term::ReadKey;
use Term::ANSIScreen qw( :cursor :screen );
use Term::ANSIColor;
use Text::Format;
use Text::SimpleTable;
use List::Util qw(min max);
use IO::Socket qw(AF_INET SOCK_STREAM SHUT_WR SHUT_RDWR SHUT_RD);
use Cache::Memcached::Fast;

BEGIN {
    require Exporter;

    our $VERSION = '0.002';
    our @ISA     = qw(Exporter);
    our @EXPORT  = qw(
      TRUE
      FALSE
	  YES
	  NO
	  BLOCKING
	  NONBLOCKING
	  PASSWORD
	  ECHO
	  SILENT
      ASCII
      ATASCII
      PETSCII
      ANSI
    );
    our @EXPORT_OK = qw();
    binmode(STDOUT, ":encoding(UTF-8)");
} ## end BEGIN

sub DESTROY {
    my $self = shift;
    $self->{'dbh'}->disconnect();
}

sub small_new {
    my $class = shift;
    my $self  = shift;

    bless($self, $class);
	$self->populate_common();
    $self->{'debug'}->DEBUGMAX([$self]);

	$self->{'CACHE'} = Cache::Memcached::Fast->new(
		{
			'servers' => [
				{
					'address' => $self->{'CONF'}->{'MEMCACHED HOST'} . ':' . $self->{'CONF'}->{'MEMCACHED PORT'},
				},
			],
			'namespace' => $self->{'CONF'}->{'MEMCACHED NAMESPACE'},
			'utf8'      => TRUE,
		}
	);
	return ($self);
} ## end sub small_new

sub new {    # Always call with the socket as a parameter
    my $class = shift;

    my $params    = shift;
    my $socket    = (exists($params->{'socket'}))        ? $params->{'socket'}        : undef;
    my $cl_socket = (exists($params->{'client_socket'})) ? $params->{'client_socket'} : undef;
    my $lmode     = (exists($params->{'local_mode'}))    ? $params->{'local_mode'}    : FALSE;

    my $os   = `/usr/bin/uname -a`;
    my $self = {
		'thread_name'     => $params->{'thread_name'},
		'thread_number'   => $params->{'thread_number'},
        'local_mode'      => $lmode,
        'debuglevel'      => $params->{'debuglevel'},
        'debug'           => $params->{'debug'},
        'socket'          => $socket,
        'cl_socket'       => $cl_socket,
        'peerhost'        => (defined($cl_socket)) ? $cl_socket->peerhost() : undef,
        'peerport'        => (defined($cl_socket)) ? $cl_socket->peerport() : undef,
        'os'              => $os,
        'width'           => 40,
        'height'          => 24,
        'tab_stop'        => 4,
        'backspace'       => chr(8),
        'carriage_return' => chr(13),
        'line_feed'       => chr(10),
        'tab_stop'        => chr(9),
        'bell'            => chr(7),
        'ack'             => chr(6),
        'nak'             => chr(15),
        'vertical_tab'    => chr(11),
        'form_feed'       => chr(12),
        'xoff'            => chr(19),
        'xon'             => chr(17),
        'esc'             => chr(27),
        'can'             => chr(24),
        'null'            => chr(0),
        'delete'          => chr(127),
        'suffixes'        => [ qw( ASC ATA PET ANS ) ],
        'host'            => undef,
        'port'            => undef,
    };

    bless($self, $class);
	$self->populate_common();
	$self->{'CACHE'} = Cache::Memcached::Fast->new(
		{
			'servers' => [
				{
					'address' => $self->{'CONF'}->{'MEMCACHED HOST'} . ':' . $self->{'CONF'}->{'MEMCACHED PORT'},
				},
			],
			'namespace' => $self->{'CONF'}->{'MEMCACHED NAMESPACE'},
			'utf8'      => TRUE,
		}
	);
    $self->{'debug'}->DEBUGMAX([$self]);

    return ($self);
} ## end sub new

sub dump_permissions {
	my $self = shift;
	return('');
}

sub populate_common {
	my $self = shift;
    $self->{'CPU'}  = $self->cpu_info();
    $self->{'CONF'} = $self->configuration();
	$self->{'VERSIONS'} = $self->parse_versions();
    $self->{'USER'} = {
        'text_mode' => $self->{'CONF'}->{'DEFAULT TEXT MODE'},
        'suffix'    => $self->{'CONF'}->{'DEFAULT SUFFIX'},
    };
	$self->db_initialize();
	$self->ascii_initialize();
	$self->atascii_initialize();
	$self->petscii_initialize();
	$self->ansi_initialize();
	$self->filetransfer_initialize();
	$self->messages_initialize();
	$self->users_initialize();
    $self->sysop_initialize();
	$self->cpu_initialize();
	$self->news_initialize();
	$self->bbs_list_initialize();
    chomp(my $os = `uname -a`);
	$self->{'SPEEDS'} = {                       # This depends on the granularity of Time::HiRes
		'FULL'  => 0,
		'300'   => 0.02,
		'1200'  => 0.005,
		'2400'  => 0.0025,
		'4800'  => 0.00125,
		'9600'  => 0.000625,
		'19200' => 0.0003125,
	};
	$self->{'TOKENS'} = {
		'SYSOP'              => ($self->{'sysop'}) ? 'SYSOP CREDENTIALS' : 'USER CREDENTIALS',
		'CPU IDENTITY'       => $self->{'CPU'}->{'CPU IDENTITY'},
		'CPU CORES'          => $self->{'CPU'}->{'CPU CORES'},
		'CPU SPEED'          => $self->{'CPU'}->{'CPU SPEED'},
		'CPU THREADS'        => $self->{'CPU'}->{'CPU THREADS'},
		'OS'                 => $os,
		'PERL VERSION'       => $self->{'VERSIONS'}->[0],
		'BBS VERSION'        => $self->{'VERSIONS'}->[1],
		'BBS LIST'           => sub {
			return($self->bbs_list_all());
		},
    	'BANNER'             => sub {
			my $self = shift;
			my $banner = $self->load_file('files/main/banner');
			return($banner);
		},
		'FILE CATEGORY' => sub {
			my $self = shift;
			return($self->users_file_category());
		},
		'FORUM CATEGORY' => sub {
			my $self = shift;
			return($self->users_forum_category());
		},
		'USER INFO'          => sub {
			my $self = shift;
			return($self->user_info());
		},
		'BBS NAME'        => sub {
			my $self = shift;
			return($self->{'CONF'}->{'BBS NAME'});
		},
		'AUTHOR NAME'        => sub {
			my $self = shift;
			return($self->{'CONF'}->{'STATIC'}->{'AUTHOR NAME'});
		},
		'USER PERMISSIONS'   => sub {
			my $self = shift;
			return($self->dump_permissions);
		},
		'USER ID'            => sub {
			my $self = shift;
			return($self->{'USER'}->{'id'});
		},
		'USERNAME'           => sub {
			my $self = shift;
			return($self->{'USER'}->{'username'});
		},
        'USER EMAIL'         => sub {
            my $self = shift;
            if ($self->{'USER'}->{'show_email'}) {
                return($self->{'USER'}->{'email'});
            } else {
                return('[HIDDEN]');
            }
        },
		'USER GIVEN'         => sub {
			my $self = shift;
			return($self->{'USER'}->{'given'});
		},
		'USER FAMILY'        => sub {
			my $self = shift;
			return($self->{'USER'}->{'family'});
		},
		'USER LOCATION'      => sub {
			my $self = shift;
			return($self->{'USER'}->{'location'});
		},
		'USER BIRTHDAY'      => sub {
			my $self = shift;
			return($self->{'USER'}->{'birthday'});
		},
		'USER RETRO SYSTEMS' => sub {
			my $self = shift;
			return($self->{'USER'}->{'retro_systems'});
		},
		'USER LOGIN TIME'    => sub {
			my $self = shift;
			return($self->{'USER'}->{'login_time'});
		},
		'USER TEXT MODE'     => sub {
			my $self = shift;
			return($self->{'USER'}->{'text_mode'});
		},
		'BAUD RATE'          => sub {
			my $self = shift;
			return($self->{'baud_rate'});
		},
		'TIME'               => sub {
			my $self = shift;
			return(DateTime->now);
		},
		'UPTIME'             => sub {
			my $self = shift;
			chomp(my $uptime = `uptime -p`);
			return($uptime);
		},
		'VERSIONS'           => 'placeholder',
		'UPTIME'             => 'placeholder',
	};
	$self->{'COMMANDS'} = {
		'BBS LIST ADD' => sub {
			my $self = shift;
			$self->bbs_list_add();
			return($self->load_menu('files/main/bbs_listing'));
		},
		'BBS LISTING' => sub {
			my $self = shift;
			return($self->load_menu('files/main/bbs_listing'));
		},
		'ACCOUNT MANAGER' => sub {
			my $self = shift;
			return($self->load_menu('files/main/account'));
		},
		'BACK' => sub {
			my $self = shift;
			return($self->load_menu('files/main/menu'));
		},
		'DISCONNECT' => sub {
			my $self = shift;

			$self->output("\nDisconnect, are you sure (Y|N)?  ");
			unless($self->decision()) {
				return($self->load_menu('files/main/menu'));
			}
			$self->output("\n");
		},
		'FILE CATEGORY' => sub {
			my $self = shift;
			$self->choose_file_category();
			return($self->load_menu('files/main/files_menu'));
		},
		'FILES' => sub {
			my $self = shift;
			return($self->load_menu('files/main/files_menu'));
		},
		'LIST FILES SUMMARY' => sub {
			my $self = shift;
			$self->files_list_summary(FALSE);
			return($self->load_menu('files/main/files_menu'));
		},
		'LIST FILES DETAILED' => sub {
			my $self = shift;
			$self->files_list_detailed(FALSE);
			return($self->load_menu('files/main/files_menu'));
		},
		'SEARCH FILES SUMMARY' => sub {
			my $self = shift;
			$self->files_list_summary(TRUE);
			return($self->load_menu('files/main/files_menu'));
		},
		'SEARCH FILES DETAILED' => sub {
			my $self = shift;
			$self->files_list_detailed(TRUE);
			return($self->load_menu('files/main/files_menu'));
		},
		'NEWS' => sub {
			my $self = shift;
			return($self->load_menu('files/main/news'));
		},
		'NEWS SUMMARY' => sub {
			my $self = shift;
			$self->news_summary();
			return($self->load_menu('files/main/news'));
		},
		'NEWS DISPLAY' => sub {
			my $self = shift;
			$self->news_display();
			return($self->load_menu('files/main/news'));
		},
		'FORUMS' => sub {
			my $self = shift;
			return($self->load_menu('files/main/menu'));
		},
		'ABOUT' => sub {
			my $self = shift;
			return($self->load_menu('files/main/about'));
		},
	};
}

sub run {
    my $self = shift;
	my $sysop = shift;

	$self->{'sysop'} = $sysop;
    $self->{'ERROR'} = undef;

    if ($self->greeting()) {    # Greeting also logs in
        $self->main_menu('files/main/menu');
    }
    $self->disconnect();
    return (defined($self->{'ERROR'}));
} ## end sub run

sub greeting {
    my $self = shift;

    $self->{'debug'}->DEBUG(['Sending greeting']);

    # Load and print greetings message here
    my $text = $self->load_file('files/main/greeting');
    $self->{'debug'}->DEBUGMAX([$text]);
    $self->output($text);
    $self->{'debug'}->DEBUG(['Greeting sent']);
    return ($self->login());    # Login will also create new users
} ## end sub greeting

sub login {
    my $self = shift;

    $self->{'debug'}->DEBUG(['Attempting login']);
    my $valid = FALSE;

    my $username;
	if ($self->{'sysop'}) {
		$username = 'sysop';
		$self->output("\n\nAuto-login of $username successful\n\n");
		$valid = $self->users_load($username,'');
	} else {
        my $tries = $self->{'CONF'}->{'LOGIN TRIES'} + 0;
        do {
            do {
                $self->output("\n" . 'Please enter your username ("NEW" if you are a new user) > ');
                $username = $self->get_line(ECHO,32);
				$tries-- if ($username eq '');
				last if ($tries <= 0 || ! $self->is_connected());
            } until($username ne '');
			if ($self->is_connected()) {
				if (uc($username) eq 'NEW') {
					$valid = $self->create_account();
				} elsif ($username eq 'sysop' && ! $self->{'local_mode'}) {
					$self->output("\n\nSysOp cannot connect remotely\n\n");
				} else {
					$self->output("\n\nPlease enter your password > ");
					my $password = $self->get_line(PASSWORD,64);
					$self->{'debug'}->DEBUG(["Attempting to load $username"]);
					$valid = $self->users_load($username,$password);
				}
				if ($valid) {
					$self->{'debug'}->DEBUG(['Login successful']);
					$self->output("\n\nWelcome " . $self->{'fullname'} . ' (' . $self->{'username'} . ")\n\n");
				} else {
					$self->{'debug'}->WARNING(["Login for $username unsuccessful"]);
					$self->output("\n\nLogin incorrect\n\n");
					$tries--;
				}
			}
			last unless ($self->{'CACHE'}->get('RUNNING'));
			last unless ($self->is_connected());
        } until($valid || $tries <= 0);
	}
	$self->{'debug'}->DEBUGMAX([$self->{'USER'}]);
    return ($valid);
} ## end sub login

sub create_account {
    my $self = shift;

    return(FALSE);
}

sub is_connected {
    my $self = shift;
	if ($self->{'CACHE'}->get('RUNNING') && ($self->{'sysop'} || defined($self->{'cl_socket'}))) {
		$self->{'CACHE'}->set(sprintf('SERVER_%02d', $self->{'thread_number'}), 'CONNECTED');
		$self->{'CACHE'}->set('UPDATE', TRUE);
		return(TRUE);
	} else {
		$self->{'CACHE'}->set(sprintf('SERVER_%02d', $self->{'thread_number'}), 'IDLE');
		$self->{'CACHE'}->set('UPDATE', TRUE);
		return(FALSE);
	}
}

sub decision {
    my $self = shift;

	my $response = uc($self->get_key(SILENT,BLOCKING));
    if ($response eq 'Y') {
		$self->output("YES\n");
		return (TRUE);
	}
    $self->output("NO\n");
    return (FALSE);
}

sub prompt {
    my $self = shift;
    my $text = shift;

    my $response;
    if ($self->{'USER'}->{'text_mode'} eq 'ATASCII') {
        $response = $text . chr(31) . ' ';
    } elsif ($self->{'USER'}->{'text_mode'} eq 'PETSCII') {
        $response = "$text > ";
    } elsif ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        $response = $text . ' ' . $self->{'ansi_sequences'}->{'BIG BULLET RIGHT'} . ' ';
    } else {
        $response = "$text > ";
    }
    return($response);
}

sub menu_choice {
    my $self   = shift;
    my $choice = shift;
    my $color  = shift;
    my $desc   = shift;

#	print "$choice - $color - $desc\n";
    if ($self->{'USER'}->{'text_mode'} eq 'ATASCII') {
        $self->output(" $choice " . chr(31) . " $desc");
    } elsif ($self->{'USER'}->{'text_mode'} eq 'PETSCII') {
        $self->output(" $choice > $desc");
    } elsif ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
		$self->output(
			$self->{'ansi_sequences'}->{'THIN VERTICAL BAR'} .
			colored([$color],$choice) .
			$self->{'ansi_sequences'}->{'THIN VERTICAL BAR'} .
			colored([$color],$self->{'ansi_sequences'}->{'BIG BULLET RIGHT'}) .
			" $desc"
		);
    } else {
        $self->output(" $choice > $desc");
    }
}

sub show_choices {
    my $self = shift;
    my $mapping = shift;

    my $keys = '';
	if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
		$self->output(
			$self->{'ansi_sequences'}->{'TOP LEFT ROUNDED'} .
			$self->{'ansi_sequences'}->{'THIN HORIZONTAL BAR'} .
			$self->{'ansi_sequences'}->{'TOP RIGHT ROUNDED'} .
			"\n"
		);
	}
    foreach my $kmenu (sort(keys %{$mapping})) {
        next if ($kmenu eq 'TEXT');
		$self->menu_choice($kmenu,$mapping->{$kmenu}->{'color'},$mapping->{$kmenu}->{'text'});
		$self->output("\n");
    }
	if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
		$self->output(
			$self->{'ansi_sequences'}->{'BOTTOM LEFT ROUNDED'} .
			$self->{'ansi_sequences'}->{'THIN HORIZONTAL BAR'} .
			$self->{'ansi_sequences'}->{'BOTTOM RIGHT ROUNDED'}
		);
	}
}

sub header {
	my $self = shift;

	my $width = $self->{'USER'}->{'max_columns'};
	my $name = ' ' . $self->{'CONF'}->{'BBS NAME'} . ' ';

	my $text = '#' x int(($width - length($name)) / 2);
	$text .= $name;
	$text .= '#' x ($width - length($text));
	if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
		my $char = '[% THICK HORIZONTAL BAR %]';
		$text =~ s/\#/$char/g;
	}
	return($self->detokenize_text('[% CLS %]' . $text));
}

sub load_menu {
	my $self = shift;
	my $file = shift;

	my $orig = $self->load_file($file);
	my @Text = split(/\n/,$orig);
	my $mapping = { 'TEXT' => '' };
	my $mode = TRUE;
	my $text = '';
	foreach my $line (@Text) {
		next if ($line =~ /^\#/);
		$self->{'debug'}->DEBUGMAX([$line]);
		if ($mode) {
			if ($line !~ /^---/) {
				my ($k, $cmd, $color, $t) = split(/\|/,$line);
				$k = uc($k);
				$cmd = uc($cmd);
				$color = uc($color);
				$color =~ s/BRIGHT /BRIGHT_/g;
				$self->{'debug'}->DEBUGMAX([$k, $cmd, $color, $t]);
				$mapping->{$k} = {
					'command' => $cmd,
					'color'   => $color,
					'text'    => $t,
				};
			} else {
				$mode = FALSE;
			}
		} else {
			$mapping->{'TEXT'} .= $self->detokenize_text($line) . "\n";
		}
	}
	$mapping->{'TEXT'} = $self->header() . "\n" . $mapping->{'TEXT'};
	return($mapping);
}

sub main_menu {
    my $self  = shift;
	my $file  = shift;

	my $connected = TRUE;
	my $command = '';
    $self->{'debug'}->DEBUG(['Main Menu loop start']);
	my $mapping = $self->load_menu($file);
    while($connected && $self->is_connected()) {
        $self->output($mapping->{'TEXT'} . "\n");
		$self->show_choices($mapping);
		$self->output("\n" . $self->prompt('Choose'));
		my $key;
		do {
			$key = uc($self->get_key(SILENT,BLOCKING));
		} until (exists($mapping->{$key}) || ! $self->is_connected());
		$self->output($mapping->{$key}->{'command'} . "\n");
		$command = $mapping->{$key}->{'command'};
		$self->{'debug'}->DEBUGMAX([$key,$mapping->{$key}]);
		$mapping = $self->{'COMMANDS'}->{$command}->($self);
		if (ref($mapping) ne 'HASH' || ! $self->is_connected()) {
			$connected = FALSE;
		}
    }
    $self->{'debug'}->DEBUG(['Main Menu end']);
} ## end sub main_menu

sub disconnect {
    my $self = shift;

    # Load and print disconnect message here
    $self->{'debug'}->DEBUG(['Send Disconnect message']);
    my $text = $self->load_file('files/main/disconnect');
    $self->output($text);
    $self->{'debug'}->DEBUG(['Disconnect message sent']);
    return (TRUE);
} ## end sub disconnect

sub categories_menu {    # Handle categories menu
    my $self = shift;

    $self->{'debug'}->DEBUG(['List Categories']);
    return (TRUE);
} ## end sub categories_menu

sub get_key {
    my $self     = shift;
    my $echo     = shift;
    my $blocking = shift;

    my $key = undef;
	local $/ = "\x{00}";
    if ($self->{'local_mode'}) {
        ReadMode 'ultra-raw';
        $key = ($blocking) ? ReadKey(0) : ReadKey(-1);
        ReadMode 'restore';
    } elsif ($self->is_connected()) {
		my $handle = $self->{'cl_socket'};
        ReadMode 'ultra-raw',$handle;
        $key = ($blocking) ? ReadKey($self->{'USER'}->{'timeout'} * 60,$handle) : ReadKey(-1,$handle);
        ReadMode 'restore',$handle;
    } ## end else [ if ($self->{'local_mode'...})]
    $self->{'debug'}->DEBUGMAX(["Key pressed - $key - " . ord($key)]);
    if ($echo == ECHO && defined($key)) {
        $key = $self->{'backspace'} if ($key eq chr(127));
        $self->output($key);
    } elsif ($echo == PASSWORD && defined($key)) {
        $self->output('*');
    }
    return ($key);
} ## end sub get_key

sub get_line {
    my $self  = shift;
    my $echo  = shift;
    my $limit = shift;

    $limit = min($limit,65535);

    my $line = '';
    my $key;

    while($self->is_connected() && $key ne chr(13) && length($line) < $limit) {
        $key = $self->get_key($echo,BLOCKING);
        if (defined($key) && $key ne '' && $self->is_connected()) {
            if ($key eq $self->{'backspace'} || $key eq chr(127)) {
                my $len = length($line);
                if ($len > 0) {
                    $line = substr($line,$len - 1);
                }
            } elsif ($key ne chr(13) && $key ne chr(10)) {
                $line .= $key;
            }
        }
		threads->yield();
    }

    if ($echo) {
        $self->{'debug'}->DEBUG(['User entered a line of text']);
        $self->{'debug'}->DEBUGMAX([$line]);
    } else {
        $self->{'debug'}->DEBUG(['User entered a password']);
    }
    return ($line);
} ## end sub get_line

sub detokenize_text {    # Detokenize text markup
    my $self = shift;
    my $text = shift;

    if (length($text) > 1) {
        $self->{'debug'}->DEBUG(['Detokenizing text']);
        $self->{'TOKENS'}->{'ONLINE'} = $self->{'CACHE'}->get('ONLINE');

        $self->{'debug'}->DEBUGMAX([$text]);    # Before
        foreach my $key (keys %{$self->{'TOKENS'}}) {
            if ($key eq 'VERSIONS' && $text =~ /$key/i) {
                my $versions = '';
                foreach my $names (@{$self->{'VERSIONS'}}) {
                    $versions .= $names . "\n";
                }
                $text =~ s/\[\%\s+$key\s+\%\]/$versions/gi;
            } elsif (ref($self->{'TOKENS'}->{$key}) eq 'CODE') {
                my $ch = $self->{'TOKENS'}->{$key}->($self); # Code call
                $text =~ s/\[\%\s+$key\s+\%\]/$ch/gi;
            } else {
                $text =~ s/\[\%\s+$key\s+\%\]/$self->{'tokens'}->{$key}/gi;
            }
        } ## end foreach my $key (keys %$tokens)
        $self->{'debug'}->DEBUGMAX([$text]);    # After
    }
    return ($text);
} ## end sub detokenize_text

sub output {
    my $self = shift;
    my $text = $self->detokenize_text(shift);

	if ($text =~ /\[\%\s+WRAP\s+\%\]/) {
		my $format = Text::Format->new(
			'columns' => $self->{'USER'}->{'max_columns'} - 1,
			'tabstop' => 4,
			'extraSpace' => TRUE,
			'firstIndent' => 0,
		);
 		my $header;
		($header,$text) = split(/\[\%\s+WRAP\s+\%\]/,$text);
		if ($text =~ /\[\%\s+JUSTIFY\s+\%\]/) {
			$text =~ s/\[\%\s+JUSTIFY\s+\%\]//g;
			$format->justify(TRUE);
		}
		$text = $format->format($text);
		$text = $header . $text;
	}
    my $mode = $self->{'USER'}->{'text_mode'};
    if ($mode eq 'ATASCII') {
        $self->{'debug'}->DEBUG(['Send ATASCII']);
        $self->atascii_output($text);
    } elsif ($mode eq 'PETSCII') {
        $self->{'debug'}->DEBUG(['Send PETSCII']);
        $self->petscii_output($text);
    } elsif ($mode eq 'ANSI') {
        $self->{'debug'}->DEBUG(['Send ANSI']);
        $self->ansi_output($text);
    } else {    # ASCII (always the default)
        $self->{'debug'}->DEBUG(['Send ASCII']);
        $self->ascii_output($text);
    }
    return (TRUE);
} ## end sub output

sub send_char {
    my $self = shift;
    my $char = shift;

    # This sends one character at a time to the socket to simulate a retro BBS
    if ($self->{'sysop'} || $self->{'local_mode'} || ! defined($self->{'cl_socket'})) {
        print $char;
    } else {
		my $handle = $self->{'cl_socket'};
		print $handle $char;
    }

    # Send at the chosen baud rate by delaying the output by a fraction of a second
    # Only delay if the baud_rate is not FULL
    sleep $self->{'SPEEDS'}->{ $self->{'baud_rate'} } if ($self->{'USER'}->{'baud_rate'} ne 'FULL');
    return (TRUE);
} ## end sub send_char

sub scroll {
	my $self = shift;
	my $nl   = shift;

	my $string;
	if ($self->{'local_mode'}) {
		$string = "\n\nScroll?  ";
	} else {
		$string = "$nl$nl" . 'Scroll?  ';
	}
	$self->send_char($string);
	if ($self->get_key(ECHO,BLOCKIMG) =~ /N/i) {
		return(FALSE);
	}
	return(TRUE);
}

sub static_configuration {
	my $self = shift;
	my $file = shift;

	$self->{'debug'}->DEBUG(['Getting static configuration']);
	$self->{'CONF'}->{'STATIC'}->{'AUTHOR NAME'} = 'Richard Kelsch';
	$self->{'CONF'}->{'STATIC'}->{'AUTHOR EMAIL'} = 'Richard Kelsch <rich@rk-internet.com>';
	$self->{'CONF'}->{'STATIC'}->{'AUTHOR LOCATION'} = 'Southern Utah - USA';
	if (-e $file) {
		open(my $CFG,'<',$file) or die "$file missing!";
		chomp(my @lines=<$CFG>);
		close($CFG);
		foreach my $line (@lines) {
			next if ($line eq '' || $line =~ /^\#/);
			my ($name,$val) = split(/\s+=\s+/,$line);
			$self->{'CONF'}->{'STATIC'}->{$name} = $val;
			$self->{'debug'}->DEBUGMAX([$name,$val]);
		}
	}
}

sub choose_file_category {
	my $self = shift;

	$self->{'debug'}->DEBUG(['Choose File Category']);
	my $table;
	my $choices = [qw(0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)];
	my $hchoice = {};
	my @categories;
	if ($self->{'USER'}->{'max_columns'} <= 40) {
		$table = Text::SimpleTable->new(6,20,15);
	} else {
		$table = Text::SimpleTable->new(6,30,43);
	}
	$table->row('CHOICE','TITLE','DESCRIPTION');
	$table->hr();
	my $sth = $self->{'dbh'}->prepare('SELECT * FROM file_categories');
	$sth->execute();
	if ($sth->rows > 0 && $sth->rows <= 35) {
		while(my $row = $sth->fetchrow_hashref()) {
			$table->row($choices->[$row->{'id'} - 1],$row->{'title'},$row->{'description'});
			$hchoice->{$choices->[$row->{'id'} - 1]} = $row->{'id'};
			push(@categories,$row->{'title'});
		}
		$sth->finish();
		if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
			$self->output($table->boxes->draw());
		} else {
			$self->output($table->draw());
		}
		$self->output("\n" . $self->prompt('Choose Category (< = Nevermind)'));
		my $response;
		do {
			$response = uc($self->get_key(SILENT,BLOCKING));
		} until (exists($hchoice->{$response}) || $response eq '<' || ! $self->is_connected());
		if ($response ne '<') {
			$self->{'USER'}->{'file_category'} = $hchoice->{$response};
			$self->output($categories[$hchoice->{$response} - 1] . "\n");
			$sth = $self->{'dbh'}->prepare('UPDATE users SET file_category=? WHERE id=?');
			$sth->execute($hchoice->{$response},$self->{'USER'}->{'id'});
			$sth->finish();
		} else {
			$self->output("Nevermind\n");
		}
	}
}

# Typical subroutines, not objects

sub configuration {
    my $self = shift;

	unless(exists($self->{'CONF'}->{'STATIC'})) {
		my @static_file = ('./conf/bbs.rc','~/.bbs_universal/bbs.rc','/etc/bbs.rc');
		my $found = FALSE;
		foreach my $file (@static_file) {
			if (-e $file) {
				$self->{'debug'}->DEBUG(["$file found"]);
				$found = TRUE;
				$self->static_configuration($file);
				last;
			} else {
				$self->{'debug'}->WARNING(["$file not found, trying the next file in the list"]);
			}
		}
		unless($found) {
			$self->{'debug'}->ERROR(['BBS Static Configuration file not found',join("\n",@static_file)]);
			exit(1);
		}
		$self->db_connect();
	}
    #######################################################
    my $count = scalar(@_);
    if ($count == 1) {    # Get single value
        my $name = shift;
		$self->{'debug'}->DEBUG(["Get configuration value for $name"]);

        my $sth = $self->{'dbh'}->prepare('SELECT config_value FROM config WHERE config_name=?');
		my $result = $sth->execute($name);
		$sth->finish();
        return ($result);
    } elsif ($count == 2) {    # Set a single value
        my $name  = shift;
        my $fval  = shift;
		$self->{'debug'}->DEBUG(["Set configuration value for $name = $fval",'Preparing']);
		my $sth = $self->{'dbh'}->prepare('UPDATE config SET config_value=? WHERE config_name=?');
		$self->{'debug'}->DEBUG(['Executing']);
		my $result = $sth->execute($fval,$name);
		$sth->finish();
		$self->{'debug'}->DEBUG(['Updated in DB']);
		$self->{'CONF'}->{$name} = $fval;
        return(TRUE);
    } elsif ($count == 0) { # Get entire configuration forces a reload into CONF
		$self->{'debug'}->DEBUG(['Query entire configurion']);
		$self->db_connect() unless(exists($self->{'dbh'}));
        my $sth = $self->{'dbh'}->prepare('SELECT config_name,config_value FROM config');
		my $results = {};
		$sth->execute();
		while(my @row = $sth->fetchrow_array()) {
			$results->{$row[0]} = $row[1];
			$self->{'CONF'}->{$row[0]} = $row[1];
		}
		$sth->finish();

        return($self->{'CONF'});
    } ## end else [ if ($count == 1) ]
} ## end sub configuration

sub parse_versions {
    my $self = shift;

    my $versions = [
		"Perl                          $OLD_PERL_VERSION",
		"BBS::Universal                $BBS::Universal::VERSION",
		"BBS::Universal::ASCII         $BBS::Universal::ASCII_VERSION",
		"BBS::Universal::ATASCII       $BBS::Universal::ATASCII_VERSION",
		"BBS::Universal::PETSCII       $BBS::Universal::PETSCII_VERSION",
		"BBS::Universal::ANSI          $BBS::Universal::ANSI_VERSION",
		"BBS::Universal::BBS_List      $BBS::Universal::BBS_LIST_VERSION",
		"BBS::Universal::CPU           $BBS::Universal::CPU_VERSION",
		"BBS::Universal::Messages      $BBS::Universal::MESSAGES_VERSION",
		"BBS::Universal::SysOp         $BBS::Universal::SYSOP_VERSION",
		"BBS::Universal::FileTransfer  $BBS::Universal::FILETRANSFER_VERSION",
		"BBS::Universal::Users         $BBS::Universal::USERS_VERSION",
		"BBS::Universal::DB            $BBS::Universal::DB_VERSION",
		"DBI                           $DBI::VERSION",
		"DBD::mysql                    $DBD::mysql::VERSION",
		"DateTime                      $DateTime::VERSION",
		"Debug::Easy                   $Debug::Easy::VERSION",
		"File::Basename                $File::Basename::VERSION",
		"Time::HiRes                   $Time::HiRes::VERSION",
		"Term::ReadKey                 $Term::ReadKey::VERSION",
		"Term::ANSIScreen              $Term::ANSIScreen::VERSION",
		"Text::Format                  $Text::Format::VERSION",
		"Text::SimpleTable             $Text::SimpleTable::VERSION",
		"IO::Socket                    $IO::Socket::VERSION",
    ];
    return ($versions);
} ## end sub parse_versions

sub yes_no {
    my $self = shift;
    my $bool = shift;

    if ($self->{'USER'}->{'text_mode'} eq 'ANSI') {
        if ($bool) {
            return('[% GREEN %]YES[% RESET %]');
        } else {
            return('[% RED %]NO[% RESET %]');
        }
    } else {
        if ($bool) {
            return('YES');
        } else {
            return('NO');
        }
    }
}

sub get_uptime {
    my $self = shift;
    chomp(my $uptime = `uptime -p`);
    return (ucfirst($uptime));
}

sub pad_center {
    my $self  = shift;
    my $text  = shift;
    my $width = shift;

    if (defined($text) && $text ne '') {
        my $size    = length($text);
        my $padding = int(($width - $size) / 2);
        if ($padding > 0) {
            $text = ' ' x $padding . $text;
        }
    } ## end if (defined($text) && ...)
    return ($text);
} ## end sub pad_center

sub center {
    my $self  = shift;
    my $text  = shift;
    my $width = shift;

    return ($text) unless (defined($text) && $text ne '');
    if ($text =~ /\n/s) {
        chomp(my @lines = split(/\n/, $text));
        $text = '';
        foreach my $line (@lines) {
            $text .= $self->pad_center($line, $width) . "\n";
        }
        return ($text);
    } else {
        return ($self->pad_center($text, $width));
    }
} ## end sub center

sub trim {
	my $self = shift;
	my $text = shift;

	$text =~ s/^\s+//;
	$text =~ s/\s+$//;
	return($text);
}

# MANUAL IMPORT HERE #

1;
